"use strict";exports.id=295,exports.ids=[295],exports.modules={63295:(t,e,i)=>{let s,o,n,r,l,a,h;i.r(e),i.d(e,{AABB:()=>g,ArrayCollisionMatrix:()=>f,BODY_SLEEP_STATES:()=>V,BODY_TYPES:()=>W,Body:()=>j,Box:()=>q,Broadphase:()=>J,COLLISION_TYPES:()=>i$,ConeTwistConstraint:()=>ee,Constraint:()=>tO,ContactEquation:()=>t$,ContactMaterial:()=>ec,ConvexPolyhedron:()=>M,Cylinder:()=>e8,DistanceConstraint:()=>ei,Equation:()=>t_,EventTarget:()=>b,FrictionEquation:()=>ea,GSSolver:()=>iq,GridBroadphase:()=>to,Heightfield:()=>ii,HingeConstraint:()=>en,JacobianElement:()=>tk,LockConstraint:()=>es,Mat3:()=>c,Material:()=>eu,NaiveBroadphase:()=>tr,Narrowphase:()=>iK,ObjectCollisionMatrix:()=>d,Particle:()=>e9,Plane:()=>it,PointToPointConstraint:()=>t5,Pool:()=>iY,Quaternion:()=>A,RAY_MODES:()=>ta,Ray:()=>th,RaycastResult:()=>tl,RaycastVehicle:()=>eF,RigidVehicle:()=>eZ,RotationalEquation:()=>t8,RotationalMotorEquation:()=>eo,SAPBroadphase:()=>tV,SHAPE_TYPES:()=>S,SPHSystem:()=>e0,Shape:()=>z,Solver:()=>iP,Sphere:()=>eK,SplitSolver:()=>iV,Spring:()=>ep,Transform:()=>C,Trimesh:()=>iw,Vec3:()=>p,Vec3Pool:()=>iX,WheelInfo:()=>eS,World:()=>s4});class d{constructor(){this.matrix={}}get(t,e){let{id:i}=t,{id:s}=e;if(s>i){let t=s;s=i,i=t}return`${i}-${s}`in this.matrix}set(t,e,i){let{id:s}=t,{id:o}=e;if(o>s){let t=o;o=s,s=t}i?this.matrix[`${s}-${o}`]=!0:delete this.matrix[`${s}-${o}`]}reset(){this.matrix={}}setNumObjects(t){}}class c{constructor(t){void 0===t&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){let t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){let t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){let e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){void 0===t&&(t=new p);let e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){void 0===e&&(e=new p);let i=this.elements,s=t.x,o=t.y,n=t.z;return e.x=i[0]*s+i[1]*o+i[2]*n,e.y=i[3]*s+i[4]*o+i[5]*n,e.z=i[6]*s+i[7]*o+i[8]*n,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){void 0===e&&(e=new c);let i=this.elements,s=t.elements,o=e.elements,n=i[0],r=i[1],l=i[2],a=i[3],h=i[4],d=i[5],u=i[6],p=i[7],y=i[8],v=s[0],m=s[1],g=s[2],w=s[3],x=s[4],f=s[5],b=s[6],A=s[7],B=s[8];return o[0]=n*v+r*w+l*b,o[1]=n*m+r*x+l*A,o[2]=n*g+r*f+l*B,o[3]=a*v+h*w+d*b,o[4]=a*m+h*x+d*A,o[5]=a*g+h*f+d*B,o[6]=u*v+p*w+y*b,o[7]=u*m+p*x+y*A,o[8]=u*g+p*f+y*B,e}scale(t,e){void 0===e&&(e=new c);let i=this.elements,s=e.elements;for(let e=0;3!==e;e++)s[3*e+0]=t.x*i[3*e+0],s[3*e+1]=t.y*i[3*e+1],s[3*e+2]=t.z*i[3*e+2];return e}solve(t,e){let i,s,o,n;void 0===e&&(e=new p);let r=[];for(i=0;i<12;i++)r.push(0);for(i=0;i<3;i++)for(s=0;s<3;s++)r[i+4*s]=this.elements[i+3*s];r[3]=t.x,r[7]=t.y,r[11]=t.z;let l=3;do{if(0===r[(i=3-l)+4*i]){for(s=i+1;s<3;s++)if(0!==r[i+4*s]){o=4;do n=4-o,r[n+4*i]+=r[n+4*s];while(--o);break}}if(0!==r[i+4*i])for(s=i+1;s<3;s++){let t=r[i+4*s]/r[i+4*i];o=4;do r[(n=4-o)+4*s]=n<=i?0:r[n+4*s]-r[n+4*i]*t;while(--o)}}while(--l);if(e.z=r[11]/r[10],e.y=(r[7]-r[6]*e.z)/r[5],e.x=(r[3]-r[2]*e.z-r[1]*e.y)/r[0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,i){if(void 0===i)return this.elements[e+3*t];this.elements[e+3*t]=i}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";for(let e=0;e<9;e++)t+=this.elements[e]+",";return t}reverse(t){let e,i,s,o;for(void 0===t&&(t=new c),e=0;e<3;e++)for(i=0;i<3;i++)u[e+6*i]=this.elements[e+3*i];u[3]=1,u[9]=0,u[15]=0,u[4]=0,u[10]=1,u[16]=0,u[5]=0,u[11]=0,u[17]=1;let n=3;do{if(0===u[(e=3-n)+6*e]){for(i=e+1;i<3;i++)if(0!==u[e+6*i]){s=6;do o=6-s,u[o+6*e]+=u[o+6*i];while(--s);break}}if(0!==u[e+6*e])for(i=e+1;i<3;i++){let t=u[e+6*i]/u[e+6*e];s=6;do u[(o=6-s)+6*i]=o<=e?0:u[o+6*i]-u[o+6*e]*t;while(--s)}}while(--n);e=2;do{i=e-1;do{let t=u[e+6*i]/u[e+6*e];s=6;do u[(o=6-s)+6*i]=u[o+6*i]-u[o+6*e]*t;while(--s)}while(i--)}while(--e);e=2;do{let t=1/u[e+6*e];s=6;do u[(o=6-s)+6*e]=u[o+6*e]*t;while(--s)}while(e--);e=2;do{i=2;do{if(isNaN(o=u[3+i+6*e])||o===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(e,i,o)}while(i--)}while(e--);return t}setRotationFromQuaternion(t){let e=t.x,i=t.y,s=t.z,o=t.w,n=e+e,r=i+i,l=s+s,a=e*n,h=e*r,d=e*l,c=i*r,u=i*l,p=s*l,y=o*n,v=o*r,m=o*l,g=this.elements;return g[0]=1-(c+p),g[1]=h-m,g[2]=d+v,g[3]=h+m,g[4]=1-(a+p),g[5]=u-y,g[6]=d-v,g[7]=u+y,g[8]=1-(a+c),this}transpose(t){let e;void 0===t&&(t=new c);let i=this.elements,s=t.elements;return s[0]=i[0],s[4]=i[4],s[8]=i[8],e=i[1],s[1]=i[3],s[3]=e,e=i[2],s[2]=i[6],s[6]=e,e=i[5],s[5]=i[7],s[7]=e,t}}let u=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class p{constructor(t,e,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),this.x=t,this.y=e,this.z=i}cross(t,e){void 0===e&&(e=new p);let i=t.x,s=t.y,o=t.z,n=this.x,r=this.y,l=this.z;return e.x=r*o-l*s,e.y=l*i-n*o,e.z=n*s-r*i,e}set(t,e,i){return this.x=t,this.y=e,this.z=i,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(!e)return new p(this.x+t.x,this.y+t.y,this.z+t.z);e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z}vsub(t,e){if(!e)return new p(this.x-t.x,this.y-t.y,this.z-t.z);e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z}crossmat(){return new c([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){let t=this.x,e=this.y,i=this.z,s=Math.sqrt(t*t+e*e+i*i);if(s>0){let t=1/s;this.x*=t,this.y*=t,this.z*=t}else this.x=0,this.y=0,this.z=0;return s}unit(t){void 0===t&&(t=new p);let e=this.x,i=this.y,s=this.z,o=Math.sqrt(e*e+i*i+s*s);return o>0?(o=1/o,t.x=e*o,t.y=i*o,t.z=s*o):(t.x=1,t.y=0,t.z=0),t}length(){let t=this.x,e=this.y,i=this.z;return Math.sqrt(t*t+e*e+i*i)}lengthSquared(){return this.dot(this)}distanceTo(t){let e=this.x,i=this.y,s=this.z,o=t.x,n=t.y,r=t.z;return Math.sqrt((o-e)*(o-e)+(n-i)*(n-i)+(r-s)*(r-s))}distanceSquared(t){let e=this.x,i=this.y,s=this.z,o=t.x,n=t.y,r=t.z;return(o-e)*(o-e)+(n-i)*(n-i)+(r-s)*(r-s)}scale(t,e){void 0===e&&(e=new p);let i=this.x,s=this.y,o=this.z;return e.x=t*i,e.y=t*s,e.z=t*o,e}vmul(t,e){return void 0===e&&(e=new p),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,i){return void 0===i&&(i=new p),i.x=this.x+t*e.x,i.y=this.y+t*e.y,i.z=this.z+t*e.z,i}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(t){return void 0===t&&(t=new p),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){let i=this.length();if(i>0){let s=1/i;y.set(this.x*s,this.y*s,this.z*s),.9>Math.abs(y.x)?v.set(1,0,0):v.set(0,1,0),y.cross(v,t),y.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,i){let s=this.x,o=this.y,n=this.z;i.x=s+(t.x-s)*e,i.y=o+(t.y-o)*e,i.z=n+(t.z-n)*e}almostEquals(t,e){return void 0===e&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return void 0===t&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(m),m.almostEquals(t,e)}clone(){return new p(this.x,this.y,this.z)}}p.ZERO=new p(0,0,0),p.UNIT_X=new p(1,0,0),p.UNIT_Y=new p(0,1,0),p.UNIT_Z=new p(0,0,1);let y=new p,v=new p,m=new p;class g{constructor(t){void 0===t&&(t={}),this.lowerBound=new p,this.upperBound=new p,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,i,s){let o=this.lowerBound,n=this.upperBound;o.copy(t[0]),i&&i.vmult(o,o),n.copy(o);for(let e=1;e<t.length;e++){let s=t[e];i&&(i.vmult(s,w),s=w),s.x>n.x&&(n.x=s.x),s.x<o.x&&(o.x=s.x),s.y>n.y&&(n.y=s.y),s.y<o.y&&(o.y=s.y),s.z>n.z&&(n.z=s.z),s.z<o.z&&(o.z=s.z)}return e&&(e.vadd(o,o),e.vadd(n,n)),s&&(o.x-=s,o.y-=s,o.z-=s,n.x+=s,n.y+=s,n.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new g().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){let e=this.lowerBound,i=this.upperBound,s=t.lowerBound,o=t.upperBound,n=s.x<=i.x&&i.x<=o.x||e.x<=o.x&&o.x<=i.x,r=s.y<=i.y&&i.y<=o.y||e.y<=o.y&&o.y<=i.y,l=s.z<=i.z&&i.z<=o.z||e.z<=o.z&&o.z<=i.z;return n&&r&&l}volume(){let t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){let e=this.lowerBound,i=this.upperBound,s=t.lowerBound,o=t.upperBound;return e.x<=s.x&&i.x>=o.x&&e.y<=s.y&&i.y>=o.y&&e.z<=s.z&&i.z>=o.z}getCorners(t,e,i,s,o,n,r,l){let a=this.lowerBound,h=this.upperBound;t.copy(a),e.set(h.x,a.y,a.z),i.set(h.x,h.y,a.z),s.set(a.x,h.y,h.z),o.set(h.x,a.y,h.z),n.set(a.x,h.y,a.z),r.set(a.x,a.y,h.z),l.copy(h)}toLocalFrame(t,e){let i=x[0],s=x[1],o=x[2],n=x[3],r=x[4],l=x[5],a=x[6],h=x[7];this.getCorners(i,s,o,n,r,l,a,h);for(let e=0;8!==e;e++){let i=x[e];t.pointToLocal(i,i)}return e.setFromPoints(x)}toWorldFrame(t,e){let i=x[0],s=x[1],o=x[2],n=x[3],r=x[4],l=x[5],a=x[6],h=x[7];this.getCorners(i,s,o,n,r,l,a,h);for(let e=0;8!==e;e++){let i=x[e];t.pointToWorld(i,i)}return e.setFromPoints(x)}overlapsRay(t){let{direction:e,from:i}=t,s=1/e.x,o=1/e.y,n=1/e.z,r=(this.lowerBound.x-i.x)*s,l=(this.upperBound.x-i.x)*s,a=(this.lowerBound.y-i.y)*o,h=(this.upperBound.y-i.y)*o,d=(this.lowerBound.z-i.z)*n,c=(this.upperBound.z-i.z)*n,u=Math.max(Math.max(Math.min(r,l),Math.min(a,h)),Math.min(d,c)),p=Math.min(Math.min(Math.max(r,l),Math.max(a,h)),Math.max(d,c));return!(p<0)&&!(u>p)}}let w=new p,x=[new p,new p,new p,new p,new p,new p,new p,new p];class f{constructor(){this.matrix=[]}get(t,e){let{index:i}=t,{index:s}=e;if(s>i){let t=s;s=i,i=t}return this.matrix[(i*(i+1)>>1)+s-1]}set(t,e,i){let{index:s}=t,{index:o}=e;if(o>s){let t=o;o=s,s=t}this.matrix[(s*(s+1)>>1)+o-1]=+!!i}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class b{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});let i=this._listeners;return void 0===i[t]&&(i[t]=[]),i[t].includes(e)||i[t].push(e),this}hasEventListener(t,e){if(void 0===this._listeners)return!1;let i=this._listeners;return!!(void 0!==i[t]&&i[t].includes(e))}hasAnyEventListener(t){return void 0!==this._listeners&&void 0!==this._listeners[t]}removeEventListener(t,e){if(void 0===this._listeners)return this;let i=this._listeners;if(void 0===i[t])return this;let s=i[t].indexOf(e);return -1!==s&&i[t].splice(s,1),this}dispatchEvent(t){if(void 0===this._listeners)return this;let e=this._listeners[t.type];if(void 0!==e){t.target=this;for(let i=0,s=e.length;i<s;i++)e[i].call(this,t)}return this}}class A{constructor(t,e,i,s){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=1),this.x=t,this.y=e,this.z=i,this.w=s}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){let i=Math.sin(.5*e);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(.5*e),this}toAxisAngle(t){void 0===t&&(t=new p),this.normalize();let e=2*Math.acos(this.w),i=Math.sqrt(1-this.w*this.w);return i<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/i,t.y=this.y/i,t.z=this.z/i),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e))t.tangents(B,E),this.setFromAxisAngle(B,Math.PI);else{let i=t.cross(e);this.x=i.x,this.y=i.y,this.z=i.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){void 0===e&&(e=new A);let i=this.x,s=this.y,o=this.z,n=this.w,r=t.x,l=t.y,a=t.z,h=t.w;return e.x=i*h+n*r+s*a-o*l,e.y=s*h+n*l+o*r-i*a,e.z=o*h+n*a+i*l-s*r,e.w=n*h-i*r-s*l-o*a,e}inverse(t){void 0===t&&(t=new A);let e=this.x,i=this.y,s=this.z,o=this.w;this.conjugate(t);let n=1/(e*e+i*i+s*s+o*o);return t.x*=n,t.y*=n,t.z*=n,t.w*=n,t}conjugate(t){return void 0===t&&(t=new A),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){let t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){void 0===e&&(e=new p);let i=t.x,s=t.y,o=t.z,n=this.x,r=this.y,l=this.z,a=this.w,h=a*i+r*o-l*s,d=a*s+l*i-n*o,c=a*o+n*s-r*i,u=-n*i-r*s-l*o;return e.x=h*a+-(u*n)+-(d*l)- -(c*r),e.y=d*a+-(u*r)+-(c*n)- -(h*l),e.z=c*a+-(u*l)+-(h*r)- -(d*n),e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){let i,s,o;void 0===e&&(e="YZX");let n=this.x,r=this.y,l=this.z,a=this.w;if("YZX"===e){let t=n*r+l*a;if(t>.499&&(i=2*Math.atan2(n,a),s=Math.PI/2,o=0),t<-.499&&(i=-2*Math.atan2(n,a),s=-Math.PI/2,o=0),void 0===i){let e=l*l;i=Math.atan2(2*r*a-2*n*l,1-r*r*2-2*e),s=Math.asin(2*t),o=Math.atan2(2*n*a-2*r*l,1-n*n*2-2*e)}}else throw Error(`Euler order ${e} not supported yet.`);t.y=i,t.z=s,t.x=o}setFromEuler(t,e,i,s){void 0===s&&(s="XYZ");let o=Math.cos(t/2),n=Math.cos(e/2),r=Math.cos(i/2),l=Math.sin(t/2),a=Math.sin(e/2),h=Math.sin(i/2);return"XYZ"===s?(this.x=l*n*r+o*a*h,this.y=o*a*r-l*n*h,this.z=o*n*h+l*a*r,this.w=o*n*r-l*a*h):"YXZ"===s?(this.x=l*n*r+o*a*h,this.y=o*a*r-l*n*h,this.z=o*n*h-l*a*r,this.w=o*n*r+l*a*h):"ZXY"===s?(this.x=l*n*r-o*a*h,this.y=o*a*r+l*n*h,this.z=o*n*h+l*a*r,this.w=o*n*r-l*a*h):"ZYX"===s?(this.x=l*n*r-o*a*h,this.y=o*a*r+l*n*h,this.z=o*n*h-l*a*r,this.w=o*n*r+l*a*h):"YZX"===s?(this.x=l*n*r+o*a*h,this.y=o*a*r+l*n*h,this.z=o*n*h-l*a*r,this.w=o*n*r-l*a*h):"XZY"===s&&(this.x=l*n*r-o*a*h,this.y=o*a*r-l*n*h,this.z=o*n*h+l*a*r,this.w=o*n*r+l*a*h),this}clone(){return new A(this.x,this.y,this.z,this.w)}slerp(t,e,i){let s,o,n,r,l;void 0===i&&(i=new A);let a=this.x,h=this.y,d=this.z,c=this.w,u=t.x,p=t.y,y=t.z,v=t.w;return(o=a*u+h*p+d*y+c*v)<0&&(o=-o,u=-u,p=-p,y=-y,v=-v),1-o>1e-6?(n=Math.sin(s=Math.acos(o)),r=Math.sin((1-e)*s)/n,l=Math.sin(e*s)/n):(r=1-e,l=e),i.x=r*a+l*u,i.y=r*h+l*p,i.z=r*d+l*y,i.w=r*c+l*v,i}integrate(t,e,i,s){void 0===s&&(s=new A);let o=t.x*i.x,n=t.y*i.y,r=t.z*i.z,l=this.x,a=this.y,h=this.z,d=this.w,c=.5*e;return s.x+=c*(o*d+n*h-r*a),s.y+=c*(n*d+r*l-o*h),s.z+=c*(r*d+o*a-n*l),s.w+=c*(-o*l-n*a-r*h),s}}let B=new p,E=new p,S={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class z{constructor(t){void 0===t&&(t={}),this.id=z.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=!t.collisionResponse||t.collisionResponse,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,i,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}z.idCounter=0,z.types=S;class C{constructor(t){void 0===t&&(t={}),this.position=new p,this.quaternion=new A,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return C.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return C.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return void 0===e&&(e=new p),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,i,s){return void 0===s&&(s=new p),i.vsub(t,s),e.conjugate(F),F.vmult(s,s),s}static pointToWorldFrame(t,e,i,s){return void 0===s&&(s=new p),e.vmult(i,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,i){return void 0===i&&(i=new p),t.vmult(e,i),i}static vectorToLocalFrame(t,e,i,s){return void 0===s&&(s=new p),e.w*=-1,e.vmult(i,s),e.w*=-1,s}}let F=new A;class M extends z{constructor(t){void 0===t&&(t={});let{vertices:e=[],faces:i=[],normals:s=[],axes:o,boundingSphereRadius:n}=t;super({type:z.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=i,this.faceNormals=s,0===this.faceNormals.length&&this.computeNormals(),n?this.boundingSphereRadius=n:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=o?o.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){let t=this.faces,e=this.vertices,i=this.uniqueEdges;i.length=0;let s=new p;for(let o=0;o!==t.length;o++){let n=t[o],r=n.length;for(let t=0;t!==r;t++){let o=(t+1)%r;e[n[t]].vsub(e[n[o]],s),s.normalize();let l=!1;for(let t=0;t!==i.length;t++)if(i[t].almostEquals(s)||i[t].almostEquals(s)){l=!0;break}l||i.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let e=0;e<this.faces[t].length;e++)if(!this.vertices[this.faces[t][e]])throw Error(`Vertex ${this.faces[t][e]} not found!`);let e=this.faceNormals[t]||new p;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;let i=this.vertices[this.faces[t][0]];if(0>e.dot(i)){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let e=0;e<this.faces[t].length;e++)console.warn(`.vertices[${this.faces[t][e]}] = Vec3(${this.vertices[this.faces[t][e]].toString()})`)}}}getFaceNormal(t,e){let i=this.faces[t],s=this.vertices[i[0]],o=this.vertices[i[1]],n=this.vertices[i[2]];M.computeNormal(s,o,n,e)}static computeNormal(t,e,i,s){let o=new p,n=new p;e.vsub(t,n),i.vsub(e,o),o.cross(n,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,i,s,o,n,r,l,a){let h=new p,d=-1,c=-Number.MAX_VALUE;for(let t=0;t<i.faces.length;t++){h.copy(i.faceNormals[t]),o.vmult(h,h);let e=h.dot(n);e>c&&(c=e,d=t)}let u=[];for(let t=0;t<i.faces[d].length;t++){let e=i.vertices[i.faces[d][t]],n=new p;n.copy(e),o.vmult(n,n),s.vadd(n,n),u.push(n)}d>=0&&this.clipFaceAgainstHull(n,t,e,u,r,l,a)}findSeparatingAxis(t,e,i,s,o,n,r,l){let a=new p,h=new p,d=new p,c=new p,u=new p,y=new p,v=Number.MAX_VALUE;if(this.uniqueAxes)for(let r=0;r!==this.uniqueAxes.length;r++){i.vmult(this.uniqueAxes[r],a);let l=this.testSepAxis(a,t,e,i,s,o);if(!1===l)return!1;l<v&&(v=l,n.copy(a))}else{let l=r?r.length:this.faces.length;for(let h=0;h<l;h++){let l=r?r[h]:h;a.copy(this.faceNormals[l]),i.vmult(a,a);let d=this.testSepAxis(a,t,e,i,s,o);if(!1===d)return!1;d<v&&(v=d,n.copy(a))}}if(t.uniqueAxes)for(let r=0;r!==t.uniqueAxes.length;r++){o.vmult(t.uniqueAxes[r],h);let l=this.testSepAxis(h,t,e,i,s,o);if(!1===l)return!1;l<v&&(v=l,n.copy(h))}else{let r=l?l.length:t.faces.length;for(let a=0;a<r;a++){let r=l?l[a]:a;h.copy(t.faceNormals[r]),o.vmult(h,h);let d=this.testSepAxis(h,t,e,i,s,o);if(!1===d)return!1;d<v&&(v=d,n.copy(h))}}for(let r=0;r!==this.uniqueEdges.length;r++){i.vmult(this.uniqueEdges[r],c);for(let r=0;r!==t.uniqueEdges.length;r++)if(o.vmult(t.uniqueEdges[r],u),c.cross(u,y),!y.almostZero()){y.normalize();let r=this.testSepAxis(y,t,e,i,s,o);if(!1===r)return!1;r<v&&(v=r,n.copy(y))}}return s.vsub(e,d),d.dot(n)>0&&n.negate(n),!0}testSepAxis(t,e,i,s,o,n){M.project(this,t,i,s,R),M.project(e,t,o,n,T);let r=R[0],l=R[1],a=T[0],h=T[1];if(r<h||a<l)return!1;let d=r-h,c=a-l;return d<c?d:c}calculateLocalInertia(t,e){let i=new p,s=new p;this.computeLocalAABB(s,i);let o=i.x-s.x,n=i.y-s.y,r=i.z-s.z;e.x=1/12*t*(2*n*2*n+2*r*2*r),e.y=1/12*t*(2*o*2*o+2*r*2*r),e.z=1/12*t*(2*n*2*n+2*o*2*o)}getPlaneConstantOfFace(t){let e=this.faces[t],i=this.faceNormals[t],s=this.vertices[e[0]];return-i.dot(s)}clipFaceAgainstHull(t,e,i,s,o,n,r){let l=new p,a=new p,h=new p,d=new p,c=new p,u=new p,y=new p,v=new p,m=[],g=-1,w=Number.MAX_VALUE;for(let e=0;e<this.faces.length;e++){l.copy(this.faceNormals[e]),i.vmult(l,l);let s=l.dot(t);s<w&&(w=s,g=e)}if(g<0)return;let x=this.faces[g];x.connectedFaces=[];for(let t=0;t<this.faces.length;t++)for(let e=0;e<this.faces[t].length;e++)-1!==x.indexOf(this.faces[t][e])&&t!==g&&-1===x.connectedFaces.indexOf(t)&&x.connectedFaces.push(t);let f=x.length;for(let t=0;t<f;t++){let o=this.vertices[x[t]],n=this.vertices[x[(t+1)%f]];o.vsub(n,a),h.copy(a),i.vmult(h,h),e.vadd(h,h),d.copy(this.faceNormals[g]),i.vmult(d,d),e.vadd(d,d),h.cross(d,c),c.negate(c),u.copy(o),i.vmult(u,u),e.vadd(u,u);let r=x.connectedFaces[t];y.copy(this.faceNormals[r]);let l=this.getPlaneConstantOfFace(r);v.copy(y),i.vmult(v,v);let p=l-v.dot(e);for(this.clipFaceAgainstPlane(s,m,v,p);s.length;)s.shift();for(;m.length;)s.push(m.shift())}y.copy(this.faceNormals[g]);let b=this.getPlaneConstantOfFace(g);v.copy(y),i.vmult(v,v);let A=b-v.dot(e);for(let t=0;t<s.length;t++){let e=v.dot(s[t])+A;if(e<=o&&(console.log(`clamped: depth=${e} to minDist=${o}`),e=o),e<=n){let i=s[t];if(e<=1e-6){let t={point:i,normal:v,depth:e};r.push(t)}}}}clipFaceAgainstPlane(t,e,i,s){let o,n,r=t.length;if(r<2)return e;let l=t[t.length-1],a=t[0];o=i.dot(l)+s;for(let h=0;h<r;h++){if(a=t[h],n=i.dot(a)+s,o<0)if(n<0){let t=new p;t.copy(a),e.push(t)}else{let t=new p;l.lerp(a,o/(o-n),t),e.push(t)}else if(n<0){let t=new p;l.lerp(a,o/(o-n),t),e.push(t),e.push(a)}l=a,o=n}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new p);let i=this.vertices,s=this.worldVertices;for(let o=0;o!==this.vertices.length;o++)e.vmult(i[o],s[o]),t.vadd(s[o],s[o]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){let i=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){let o=i[s];o.x<t.x?t.x=o.x:o.x>e.x&&(e.x=o.x),o.y<t.y?t.y=o.y:o.y>e.y&&(e.y=o.y),o.z<t.z?t.z=o.z:o.z>e.z&&(e.z=o.z)}}computeWorldFaceNormals(t){let e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new p);let i=this.faceNormals,s=this.worldFaceNormals;for(let o=0;o!==e;o++)t.vmult(i[o],s[o]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0,e=this.vertices;for(let i=0;i!==e.length;i++){let s=e[i].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,i,s){let o,n,r,l,a,h,d=this.vertices,c=new p;for(let i=0;i<d.length;i++)c.copy(d[i]),e.vmult(c,c),t.vadd(c,c),(void 0===o||c.x<o)&&(o=c.x),(void 0===l||c.x>l)&&(l=c.x),(void 0===n||c.y<n)&&(n=c.y),(void 0===a||c.y>a)&&(a=c.y),(void 0===r||c.z<r)&&(r=c.z),(void 0===h||c.z>h)&&(h=c.z);i.set(o,n,r),s.set(l,a,h)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){void 0===t&&(t=new p);let e=this.vertices;for(let i=0;i<e.length;i++)t.vadd(e[i],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){let i=this.vertices.length,s=this.vertices;if(e){for(let t=0;t<i;t++){let i=s[t];e.vmult(i,i)}for(let t=0;t<this.faceNormals.length;t++){let i=this.faceNormals[t];e.vmult(i,i)}}if(t)for(let e=0;e<i;e++){let i=s[e];i.vadd(t,i)}}pointIsInside(t){let e=this.vertices,i=this.faces,s=this.faceNormals,o=new p;this.getAveragePointLocal(o);for(let n=0;n<this.faces.length;n++){let r=s[n],l=e[i[n][0]],a=new p;t.vsub(l,a);let h=r.dot(a),d=new p;o.vsub(l,d);let c=r.dot(d);if(h<0&&c>0||h>0&&c<0)return!1}return -1}static project(t,e,i,s,o){let n=t.vertices.length,r=0,l=0,a=t.vertices;P.setZero(),C.vectorToLocalFrame(i,s,e,I),C.pointToLocalFrame(i,s,P,P);let h=P.dot(I);l=r=a[0].dot(I);for(let t=1;t<n;t++){let e=a[t].dot(I);e>r&&(r=e),e<l&&(l=e)}if((l-=h)>(r-=h)){let t=l;l=r,r=t}o[0]=r,o[1]=l}}let R=[],T=[];new p;let I=new p,P=new p;class q extends z{constructor(t){super({type:z.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){let t=this.halfExtents.x,e=this.halfExtents.y,i=this.halfExtents.z,s=new M({vertices:[new p(-t,-e,-i),new p(t,-e,-i),new p(t,e,-i),new p(-t,e,-i),new p(-t,-e,i),new p(t,-e,i),new p(t,e,i),new p(-t,e,i)],faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:[new p(0,0,1),new p(0,1,0),new p(1,0,0)]});this.convexPolyhedronRepresentation=s,s.material=this.material}calculateLocalInertia(t,e){return void 0===e&&(e=new p),q.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,i){i.x=1/12*e*(2*t.y*2*t.y+2*t.z*2*t.z),i.y=1/12*e*(2*t.x*2*t.x+2*t.z*2*t.z),i.z=1/12*e*(2*t.y*2*t.y+2*t.x*2*t.x)}getSideNormals(t,e){let i=this.halfExtents;if(t[0].set(i.x,0,0),t[1].set(0,i.y,0),t[2].set(0,0,i.z),t[3].set(-i.x,0,0),t[4].set(0,-i.y,0),t[5].set(0,0,-i.z),void 0!==e)for(let i=0;i!==t.length;i++)e.vmult(t[i],t[i]);return t}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,i){let s=this.halfExtents,o=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let s=0;s<o.length;s++)N.set(o[s][0],o[s][1],o[s][2]),e.vmult(N,N),t.vadd(N,N),i(N.x,N.y,N.z)}calculateWorldAABB(t,e,i,s){let o=this.halfExtents;L[0].set(o.x,o.y,o.z),L[1].set(-o.x,o.y,o.z),L[2].set(-o.x,-o.y,o.z),L[3].set(-o.x,-o.y,-o.z),L[4].set(o.x,-o.y,-o.z),L[5].set(o.x,o.y,-o.z),L[6].set(-o.x,o.y,-o.z),L[7].set(o.x,-o.y,o.z);let n=L[0];e.vmult(n,n),t.vadd(n,n),s.copy(n),i.copy(n);for(let o=1;o<8;o++){let n=L[o];e.vmult(n,n),t.vadd(n,n);let r=n.x,l=n.y,a=n.z;r>s.x&&(s.x=r),l>s.y&&(s.y=l),a>s.z&&(s.z=a),r<i.x&&(i.x=r),l<i.y&&(i.y=l),a<i.z&&(i.z=a)}}}let N=new p,L=[new p,new p,new p,new p,new p,new p,new p,new p],W={DYNAMIC:1,STATIC:2,KINEMATIC:4},V={AWAKE:0,SLEEPY:1,SLEEPING:2};class j extends b{constructor(t){void 0===t&&(t={}),super(),this.id=j.idCounter++,this.index=-1,this.world=null,this.vlambda=new p,this.collisionFilterGroup="number"==typeof t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof t.collisionResponse||t.collisionResponse,this.position=new p,this.previousPosition=new p,this.interpolatedPosition=new p,this.initPosition=new p,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new p,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new p,this.force=new p;let e="number"==typeof t.mass?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping="number"==typeof t.linearDamping?t.linearDamping:.01,this.type=e<=0?j.STATIC:j.DYNAMIC,typeof t.type==typeof j.STATIC&&(this.type=t.type),this.allowSleep=void 0===t.allowSleep||t.allowSleep,this.sleepState=j.AWAKE,this.sleepSpeedLimit=void 0!==t.sleepSpeedLimit?t.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==t.sleepTimeLimit?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new p,this.quaternion=new A,this.initQuaternion=new A,this.previousQuaternion=new A,this.interpolatedQuaternion=new A,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new p,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new p,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new p,this.invInertia=new p,this.invInertiaWorld=new c,this.invMassSolve=0,this.invInertiaSolve=new p,this.invInertiaWorldSolve=new c,this.fixedRotation=void 0!==t.fixedRotation&&t.fixedRotation,this.angularDamping=void 0!==t.angularDamping?t.angularDamping:.01,this.linearFactor=new p(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new p(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new g,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new p,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){let t=this.sleepState;this.sleepState=j.AWAKE,this.wakeUpAfterNarrowphase=!1,t===j.SLEEPING&&this.dispatchEvent(j.wakeupEvent)}sleep(){this.sleepState=j.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){let e=this.sleepState,i=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===j.AWAKE&&i<s?(this.sleepState=j.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(j.sleepyEvent)):e===j.SLEEPY&&i>s?this.wakeUp():e===j.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(j.sleepEvent))}}updateSolveMassProperties(){this.sleepState===j.SLEEPING||this.type===j.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return void 0===e&&(e=new p),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return void 0===e&&(e=new p),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return void 0===e&&(e=new p),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return void 0===e&&(e=new p),this.quaternion.vmult(t,e),e}addShape(t,e,i){let s=new p,o=new A;return e&&s.copy(e),i&&o.copy(i),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(o),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){let e=this.shapes.indexOf(t);return -1===e?console.warn("Shape does not belong to the body"):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null),this}updateBoundingRadius(){let t=this.shapes,e=this.shapeOffsets,i=t.length,s=0;for(let o=0;o!==i;o++){let i=t[o];i.updateBoundingSphereRadius();let n=e[o].length(),r=i.boundingSphereRadius;n+r>s&&(s=n+r)}this.boundingRadius=s}updateAABB(){let t=this.shapes,e=this.shapeOffsets,i=this.shapeOrientations,s=t.length,o=this.quaternion,n=this.aabb;for(let r=0;r!==s;r++){let s=t[r];o.vmult(e[r],O),O.vadd(this.position,O),o.mult(i[r],k),s.calculateWorldAABB(O,k,_.lowerBound,_.upperBound),0===r?n.copy(_):n.extend(_)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){let e=this.invInertia;(e.x!==e.y||e.y!==e.z||t)&&(H.setRotationFromQuaternion(this.quaternion),H.transpose(D),H.scale(e,H),H.mmult(D,this.invInertiaWorld))}applyForce(t,e){void 0===e&&(e=new p),this.type===j.DYNAMIC&&(this.sleepState===j.SLEEPING&&this.wakeUp(),e.cross(t,U),this.force.vadd(t,this.force),this.torque.vadd(U,this.torque))}applyLocalForce(t,e){void 0===e&&(e=new p),this.type===j.DYNAMIC&&(this.vectorToWorldFrame(t,G),this.vectorToWorldFrame(e,Y),this.applyForce(G,Y))}applyTorque(t){this.type===j.DYNAMIC&&(this.sleepState===j.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(void 0===e&&(e=new p),this.type!==j.DYNAMIC)return;this.sleepState===j.SLEEPING&&this.wakeUp();let i=e;X.copy(t),X.scale(this.invMass,X),this.velocity.vadd(X,this.velocity),i.cross(t,$),this.invInertiaWorld.vmult($,$),this.angularVelocity.vadd($,this.angularVelocity)}applyLocalImpulse(t,e){void 0===e&&(e=new p),this.type===j.DYNAMIC&&(this.vectorToWorldFrame(t,K),this.vectorToWorldFrame(e,Z),this.applyImpulse(K,Z))}updateMassProperties(){this.invMass=this.mass>0?1/this.mass:0;let t=this.inertia,e=this.fixedRotation;this.updateAABB(),Q.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),q.calculateInertia(Q,this.mass,t),this.invInertia.set(t.x>0&&!e?1/t.x:0,t.y>0&&!e?1/t.y:0,t.z>0&&!e?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){let i=new p;return t.vsub(this.position,i),this.angularVelocity.cross(i,e),this.velocity.vadd(e,e),e}integrate(t,e,i){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==j.DYNAMIC&&this.type!==j.KINEMATIC||this.sleepState===j.SLEEPING)return;let s=this.velocity,o=this.angularVelocity,n=this.position,r=this.force,l=this.torque,a=this.quaternion,h=this.invMass,d=this.invInertiaWorld,c=this.linearFactor,u=h*t;s.x+=r.x*u*c.x,s.y+=r.y*u*c.y,s.z+=r.z*u*c.z;let p=d.elements,y=this.angularFactor,v=l.x*y.x,m=l.y*y.y,g=l.z*y.z;o.x+=t*(p[0]*v+p[1]*m+p[2]*g),o.y+=t*(p[3]*v+p[4]*m+p[5]*g),o.z+=t*(p[6]*v+p[7]*m+p[8]*g),n.x+=s.x*t,n.y+=s.y*t,n.z+=s.z*t,a.integrate(this.angularVelocity,t,this.angularFactor,a),e&&(i?a.normalizeFast():a.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}j.idCounter=0,j.COLLIDE_EVENT_NAME="collide",j.DYNAMIC=W.DYNAMIC,j.STATIC=W.STATIC,j.KINEMATIC=W.KINEMATIC,j.AWAKE=V.AWAKE,j.SLEEPY=V.SLEEPY,j.SLEEPING=V.SLEEPING,j.wakeupEvent={type:"wakeup"},j.sleepyEvent={type:"sleepy"},j.sleepEvent={type:"sleep"};let O=new p,k=new A,_=new g,H=new c,D=new c;new c;let U=new p,G=new p,Y=new p,X=new p,$=new p,K=new p,Z=new p,Q=new p;class J{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,i){throw Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return(t.collisionFilterGroup&e.collisionFilterMask)!=0&&(e.collisionFilterGroup&t.collisionFilterMask)!=0&&((t.type&j.STATIC)==0&&t.sleepState!==j.SLEEPING||(e.type&j.STATIC)==0&&e.sleepState!==j.SLEEPING)}intersectionTest(t,e,i,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,i,s):this.doBoundingSphereBroadphase(t,e,i,s)}doBoundingSphereBroadphase(t,e,i,s){e.position.vsub(t.position,tt);let o=(t.boundingRadius+e.boundingRadius)**2;tt.lengthSquared()<o&&(i.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,i,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(i.push(t),s.push(e))}makePairsUnique(t,e){let i=t.length;for(let s=0;s!==i;s++)ti[s]=t[s],ts[s]=e[s];t.length=0,e.length=0;for(let t=0;t!==i;t++){let e=ti[t].id,i=ts[t].id,s=e<i?`${e},${i}`:`${i},${e}`;te[s]=t,te.keys.push(s)}for(let i=0;i!==te.keys.length;i++){let i=te.keys.pop(),s=te[i];t.push(ti[s]),e.push(ts[s]),delete te[i]}}setWorld(t){}static boundingSphereCheck(t,e){let i=new p;t.position.vsub(e.position,i);let s=t.shapes[0],o=e.shapes[0];return Math.pow(s.boundingSphereRadius+o.boundingSphereRadius,2)>i.lengthSquared()}aabbQuery(t,e,i){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}let tt=new p;new p,new A,new p;let te={keys:[]},ti=[],ts=[];new p;class to extends J{constructor(t,e,i,s,o){void 0===t&&(t=new p(100,100,100)),void 0===e&&(e=new p(-100,-100,-100)),void 0===i&&(i=10),void 0===s&&(s=10),void 0===o&&(o=10),super(),this.nx=i,this.ny=s,this.nz=o,this.aabbMin=t,this.aabbMax=e;let n=this.nx*this.ny*this.nz;if(n<=0)throw"GridBroadphase: Each dimension's n must be >0";this.bins=[],this.binLengths=[],this.bins.length=n,this.binLengths.length=n;for(let t=0;t<n;t++)this.bins[t]=[],this.binLengths[t]=0}collisionPairs(t,e,i){let s=t.bodies.length,o=t.bodies,n=this.aabbMax,r=this.aabbMin,l=this.nx,a=this.ny,h=this.nz,d=a*h,c=n.x,u=n.y,p=n.z,y=r.x,v=r.y,m=r.z,g=l/(c-y),w=a/(u-v),x=h/(p-m),f=(c-y)/l,b=(u-v)/a,A=(p-m)/h,B=.5*Math.sqrt(f*f+b*b+A*A),E=z.types,S=E.SPHERE,C=E.PLANE;E.BOX,E.COMPOUND,E.CONVEXPOLYHEDRON;let F=this.bins,M=this.binLengths,R=this.bins.length;for(let t=0;t!==R;t++)M[t]=0;let T=Math.ceil;function I(t,e,i,s,o,n,r){let c=(t-y)*g|0,u=(e-v)*w|0,p=(i-m)*x|0,f=T((s-y)*g),b=T((o-v)*w),A=T((n-m)*x);c<0?c=0:c>=l&&(c=l-1),u<0?u=0:u>=a&&(u=a-1),p<0?p=0:p>=h&&(p=h-1),f<0?f=0:f>=l&&(f=l-1),b<0?b=0:b>=a&&(b=a-1),A<0?A=0:A>=h&&(A=h-1),c*=d,u*=h,p*=1,f*=d,b*=h,A*=1;for(let t=c;t<=f;t+=d)for(let e=u;e<=b;e+=h)for(let i=p;i<=A;i+=1){let s=t+e+i;F[s][M[s]++]=r}}for(let t=0;t!==s;t++){let e=o[t],i=e.shapes[0];switch(i.type){case S:{let t=e.position.x,s=e.position.y,o=e.position.z,n=i.radius;I(t-n,s-n,o-n,t+n,s+n,o+n,e);break}case C:{i.worldNormalNeedsUpdate&&i.computeWorldNormal(e.quaternion);let t=i.worldNormal,s=y+.5*f-e.position.x,o=v+.5*b-e.position.y,n=m+.5*A-e.position.z;tn.set(s,o,n);for(let i=0,s=0;i!==l;i++,s+=d,tn.y=o,tn.x+=f)for(let i=0,o=0;i!==a;i++,o+=h,tn.z=n,tn.y+=b)for(let i=0,n=0;i!==h;i++,n+=1,tn.z+=A)if(tn.dot(t)<B){let t=s+o+n;F[t][M[t]++]=e}break}default:e.aabbNeedsUpdate&&e.updateAABB(),I(e.aabb.lowerBound.x,e.aabb.lowerBound.y,e.aabb.lowerBound.z,e.aabb.upperBound.x,e.aabb.upperBound.y,e.aabb.upperBound.z,e)}}for(let t=0;t!==R;t++){let s=M[t];if(s>1){let o=F[t];for(let t=0;t!==s;t++){let s=o[t];for(let n=0;n!==t;n++){let t=o[n];this.needBroadphaseCollision(s,t)&&this.intersectionTest(s,t,e,i)}}}}this.makePairsUnique(e,i)}}let tn=new p;new p;class tr extends J{constructor(){super()}collisionPairs(t,e,i){let s,o,n=t.bodies,r=n.length;for(let t=0;t!==r;t++)for(let r=0;r!==t;r++)s=n[t],o=n[r],this.needBroadphaseCollision(s,o)&&this.intersectionTest(s,o,e,i)}aabbQuery(t,e,i){void 0===i&&(i=[]);for(let s=0;s<t.bodies.length;s++){let o=t.bodies[s];o.aabbNeedsUpdate&&o.updateAABB(),o.aabb.overlaps(e)&&i.push(o)}return i}}class tl{constructor(){this.rayFromWorld=new p,this.rayToWorld=new p,this.hitNormalWorld=new p,this.hitPointWorld=new p,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,i,s,o,n,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(i),this.hitPointWorld.copy(s),this.shape=o,this.body=n,this.distance=r}}let ta={CLOSEST:1,ANY:2,ALL:4};s=z.types.SPHERE,o=z.types.PLANE,n=z.types.BOX,r=z.types.CYLINDER,l=z.types.CONVEXPOLYHEDRON,a=z.types.HEIGHTFIELD,h=z.types.TRIMESH;class th{get[s](){return this._intersectSphere}get[o](){return this._intersectPlane}get[n](){return this._intersectBox}get[r](){return this._intersectConvex}get[l](){return this._intersectConvex}get[a](){return this._intersectHeightfield}get[h](){return this._intersectTrimesh}constructor(t,e){void 0===t&&(t=new p),void 0===e&&(e=new p),this.from=t.clone(),this.to=e.clone(),this.direction=new p,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=th.ANY,this.result=new tl,this.hasHit=!1,this.callback=t=>{}}intersectWorld(t,e){return this.mode=e.mode||th.ANY,this.result=e.result||new tl,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===e.checkCollisionResponse||e.checkCollisionResponse,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(td),tc.length=0,t.broadphase.aabbQuery(t,td,tc),this.intersectBodies(tc),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());let i=this.checkCollisionResponse;if((!i||t.collisionResponse)&&(this.collisionFilterGroup&t.collisionFilterMask)!=0&&(t.collisionFilterGroup&this.collisionFilterMask)!=0)for(let e=0,s=t.shapes.length;e<s;e++){let s=t.shapes[e];if((!i||s.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[e],tv),t.quaternion.vmult(t.shapeOffsets[e],ty),ty.vadd(t.position,ty),this.intersectShape(s,tv,ty,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let e=0,i=t.length;!this.result.shouldStop&&e<i;e++)this.intersectBody(t[e])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,i,s){if(function(t,e,i){i.vsub(t,tL);let s=tL.dot(e);return e.scale(s,tW),tW.vadd(t,tW),i.distanceTo(tW)}(this.from,this.direction,i)>t.boundingSphereRadius)return;let o=this[t.type];o&&o.call(this,t,e,i,s,t)}_intersectBox(t,e,i,s,o){return this._intersectConvex(t.convexPolyhedronRepresentation,e,i,s,o)}_intersectPlane(t,e,i,s,o){let n=this.from,r=this.to,l=this.direction,a=new p(0,0,1);e.vmult(a,a);let h=new p;n.vsub(i,h);let d=h.dot(a);if(r.vsub(i,h),d*h.dot(a)>0||n.distanceTo(r)<d)return;let c=a.dot(l);if(Math.abs(c)<this.precision)return;let u=new p,y=new p,v=new p;n.vsub(i,u);let m=-a.dot(u)/c;l.scale(m,y),n.vadd(y,v),this.reportIntersection(a,v,o,s,-1)}getAABB(t){let{lowerBound:e,upperBound:i}=t,s=this.to,o=this.from;e.x=Math.min(s.x,o.x),e.y=Math.min(s.y,o.y),e.z=Math.min(s.z,o.z),i.x=Math.max(s.x,o.x),i.y=Math.max(s.y,o.y),i.z=Math.max(s.z,o.z)}_intersectHeightfield(t,e,i,s,o){let n,r,l,a;t.data,t.elementSize,tA.from.copy(this.from),tA.to.copy(this.to),C.pointToLocalFrame(i,e,tA.from,tA.from),C.pointToLocalFrame(i,e,tA.to,tA.to),tA.updateDirection(),n=r=0,l=a=t.data.length-1;let h=new g;tA.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,tB,!0),n=Math.max(n,tB[0]),r=Math.max(r,tB[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,tB,!0),l=Math.min(l,tB[0]+1),a=Math.min(a,tB[1]+1);for(let d=n;d<l;d++)for(let n=r;n<a;n++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(d,n,h),h.overlapsRay(tA)){if(t.getConvexTrianglePillar(d,n,!1),C.pointToWorldFrame(i,e,t.pillarOffset,tb),this._intersectConvex(t.pillarConvex,e,tb,s,o,tf),this.result.shouldStop)return;t.getConvexTrianglePillar(d,n,!0),C.pointToWorldFrame(i,e,t.pillarOffset,tb),this._intersectConvex(t.pillarConvex,e,tb,s,o,tf)}}}_intersectSphere(t,e,i,s,o){let n=this.from,r=this.to,l=t.radius,a=(r.x-n.x)**2+(r.y-n.y)**2+(r.z-n.z)**2,h=2*((r.x-n.x)*(n.x-i.x)+(r.y-n.y)*(n.y-i.y)+(r.z-n.z)*(n.z-i.z)),d=h**2-4*a*((n.x-i.x)**2+(n.y-i.y)**2+(n.z-i.z)**2-l**2);if(!(d<0))if(0===d)n.lerp(r,d,tE),tE.vsub(i,tS),tS.normalize(),this.reportIntersection(tS,tE,o,s,-1);else{let t=(-h-Math.sqrt(d))/(2*a),e=(-h+Math.sqrt(d))/(2*a);if(t>=0&&t<=1&&(n.lerp(r,t,tE),tE.vsub(i,tS),tS.normalize(),this.reportIntersection(tS,tE,o,s,-1)),this.result.shouldStop)return;e>=0&&e<=1&&(n.lerp(r,e,tE),tE.vsub(i,tS),tS.normalize(),this.reportIntersection(tS,tE,o,s,-1))}}_intersectConvex(t,e,i,s,o,n){let r=n&&n.faceList||null,l=t.faces,a=t.vertices,h=t.faceNormals,d=this.direction,c=this.from,u=this.to,p=c.distanceTo(u),y=r?r.length:l.length,v=this.result;for(let t=0;!v.shouldStop&&t<y;t++){let n=r?r[t]:t,u=l[n],y=h[n];tC.copy(a[u[0]]),e.vmult(tC,tC),tC.vadd(i,tC),tC.vsub(c,tC),e.vmult(y,tz);let m=d.dot(tz);if(Math.abs(m)<this.precision)continue;let g=tz.dot(tC)/m;if(!(g<0)){d.scale(g,tm),tm.vadd(c,tm),tg.copy(a[u[0]]),e.vmult(tg,tg),i.vadd(tg,tg);for(let t=1;!v.shouldStop&&t<u.length-1;t++){tw.copy(a[u[t]]),tx.copy(a[u[t+1]]),e.vmult(tw,tw),e.vmult(tx,tx),i.vadd(tw,tw),i.vadd(tx,tx);let r=tm.distanceTo(c);(th.pointInTriangle(tm,tg,tw,tx)||th.pointInTriangle(tm,tw,tg,tx))&&!(r>p)&&this.reportIntersection(tz,tm,o,s,n)}}}}_intersectTrimesh(t,e,i,s,o,n){let r=t.indices;t.vertices;let l=this.from,a=this.to,h=this.direction;tN.position.copy(i),tN.quaternion.copy(e),C.vectorToLocalFrame(i,e,h,tM),C.pointToLocalFrame(i,e,l,tR),C.pointToLocalFrame(i,e,a,tT),tT.x*=t.scale.x,tT.y*=t.scale.y,tT.z*=t.scale.z,tR.x*=t.scale.x,tR.y*=t.scale.y,tR.z*=t.scale.z,tT.vsub(tR,tM),tM.normalize();let d=tR.distanceSquared(tT);t.tree.rayQuery(this,tN,tq);for(let n=0,l=tq.length;!this.result.shouldStop&&n!==l;n++){let l=tq[n];t.getNormal(l,tF),t.getVertex(r[3*l],tg),tg.vsub(tR,tC);let a=tM.dot(tF),h=tF.dot(tC)/a;if(h<0)continue;tM.scale(h,tm),tm.vadd(tR,tm),t.getVertex(r[3*l+1],tw),t.getVertex(r[3*l+2],tx);let c=tm.distanceSquared(tR);(th.pointInTriangle(tm,tw,tg,tx)||th.pointInTriangle(tm,tg,tw,tx))&&!(c>d)&&(C.vectorToWorldFrame(e,tF,tI),C.pointToWorldFrame(i,e,tm,tP),this.reportIntersection(tI,tP,o,s,l))}tq.length=0}reportIntersection(t,e,i,s,o){let n=this.from,r=this.to,l=n.distanceTo(e),a=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(a.hitFaceIndex=void 0!==o?o:-1,this.mode){case th.ALL:this.hasHit=!0,a.set(n,r,t,e,i,s,l),a.hasHit=!0,this.callback(a);break;case th.CLOSEST:(l<a.distance||!a.hasHit)&&(this.hasHit=!0,a.hasHit=!0,a.set(n,r,t,e,i,s,l));break;case th.ANY:this.hasHit=!0,a.hasHit=!0,a.set(n,r,t,e,i,s,l),a.shouldStop=!0}}static pointInTriangle(t,e,i,s){let o,n;s.vsub(e,tL),i.vsub(e,tu),t.vsub(e,tp);let r=tL.dot(tL),l=tL.dot(tu),a=tL.dot(tp),h=tu.dot(tu),d=tu.dot(tp);return(o=h*a-l*d)>=0&&(n=r*d-l*a)>=0&&o+n<r*h-l*l}}th.CLOSEST=ta.CLOSEST,th.ANY=ta.ANY,th.ALL=ta.ALL;let td=new g,tc=[],tu=new p,tp=new p,ty=new p,tv=new A,tm=new p,tg=new p,tw=new p,tx=new p;new p,new tl;let tf={faceList:[0]},tb=new p,tA=new th,tB=[],tE=new p,tS=new p,tz=new p;new p,new p;let tC=new p,tF=new p,tM=new p,tR=new p,tT=new p,tI=new p,tP=new p;new g;let tq=[],tN=new C,tL=new p,tW=new p;class tV extends J{static checkBounds(t,e,i){let s,o;0===i?(s=t.position.x,o=e.position.x):1===i?(s=t.position.y,o=e.position.y):2===i&&(s=t.position.z,o=e.position.z);let n=t.boundingRadius;return o-e.boundingRadius<s+n}static insertionSortX(t){for(let e=1,i=t.length;e<i;e++){let i,s=t[e];for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.x<=s.aabb.lowerBound.x);i--)t[i+1]=t[i];t[i+1]=s}return t}static insertionSortY(t){for(let e=1,i=t.length;e<i;e++){let i,s=t[e];for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.y<=s.aabb.lowerBound.y);i--)t[i+1]=t[i];t[i+1]=s}return t}static insertionSortZ(t){for(let e=1,i=t.length;e<i;e++){let i,s=t[e];for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.z<=s.aabb.lowerBound.z);i--)t[i+1]=t[i];t[i+1]=s}return t}constructor(t){super(),this.axisList=[],this.world=null,this.axisIndex=0;let e=this.axisList;this._addBodyHandler=t=>{e.push(t.body)},this._removeBodyHandler=t=>{let i=e.indexOf(t.body);-1!==i&&e.splice(i,1)},t&&this.setWorld(t)}setWorld(t){this.axisList.length=0;for(let e=0;e<t.bodies.length;e++)this.axisList.push(t.bodies[e]);t.removeEventListener("addBody",this._addBodyHandler),t.removeEventListener("removeBody",this._removeBodyHandler),t.addEventListener("addBody",this._addBodyHandler),t.addEventListener("removeBody",this._removeBodyHandler),this.world=t,this.dirty=!0}collisionPairs(t,e,i){let s,o,n=this.axisList,r=n.length,l=this.axisIndex;for(this.dirty&&(this.sortList(),this.dirty=!1),s=0;s!==r;s++){let t=n[s];for(o=s+1;o<r;o++){let s=n[o];if(this.needBroadphaseCollision(t,s)){if(!tV.checkBounds(t,s,l))break;this.intersectionTest(t,s,e,i)}}}}sortList(){let t=this.axisList,e=this.axisIndex,i=t.length;for(let e=0;e!==i;e++){let i=t[e];i.aabbNeedsUpdate&&i.updateAABB()}0===e?tV.insertionSortX(t):1===e?tV.insertionSortY(t):2===e&&tV.insertionSortZ(t)}autoDetectAxis(){let t=0,e=0,i=0,s=0,o=0,n=0,r=this.axisList,l=r.length,a=1/l;for(let a=0;a!==l;a++){let l=r[a],h=l.position.x;t+=h,e+=h*h;let d=l.position.y;i+=d,s+=d*d;let c=l.position.z;o+=c,n+=c*c}let h=e-t*t*a,d=s-i*i*a,c=n-o*o*a;h>d?h>c?this.axisIndex=0:this.axisIndex=2:d>c?this.axisIndex=1:this.axisIndex=2}aabbQuery(t,e,i){void 0===i&&(i=[]),this.dirty&&(this.sortList(),this.dirty=!1);let s=this.axisIndex,o="x";1===s&&(o="y"),2===s&&(o="z");let n=this.axisList;e.lowerBound[o],e.upperBound[o];for(let t=0;t<n.length;t++){let s=n[t];s.aabbNeedsUpdate&&s.updateAABB(),s.aabb.overlaps(e)&&i.push(s)}return i}}class tj{static defaults(t,e){for(let i in void 0===t&&(t={}),e)i in t||(t[i]=e[i]);return t}}class tO{constructor(t,e,i){void 0===i&&(i={}),i=tj.defaults(i,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=t,this.bodyB=e,this.id=tO.idCounter++,this.collideConnected=i.collideConnected,i.wakeUpBodies&&(t&&t.wakeUp(),e&&e.wakeUp())}update(){throw Error("method update() not implmemented in this Constraint subclass!")}enable(){let t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!0}disable(){let t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!1}}tO.idCounter=0;class tk{constructor(){this.spatial=new p,this.rotational=new p}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class t_{constructor(t,e,i,s){void 0===i&&(i=-1e6),void 0===s&&(s=1e6),this.id=t_.idCounter++,this.minForce=i,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new tk,this.jacobianElementB=new tk,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,i){this.a=4/(i*(1+4*e)),this.b=4*e/(1+4*e),this.eps=4/(i*i*t*(1+4*e))}computeB(t,e,i){let s=this.computeGW();return-this.computeGq()*t-s*e-this.computeGiMf()*i}computeGq(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.position,n=s.position;return t.spatial.dot(o)+e.spatial.dot(n)}computeGW(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.velocity,n=s.velocity,r=i.angularVelocity,l=s.angularVelocity;return t.multiplyVectors(o,r)+e.multiplyVectors(n,l)}computeGWlambda(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.vlambda,n=s.vlambda,r=i.wlambda,l=s.wlambda;return t.multiplyVectors(o,r)+e.multiplyVectors(n,l)}computeGiMf(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.force,n=i.torque,r=s.force,l=s.torque,a=i.invMassSolve,h=s.invMassSolve;return o.scale(a,tH),r.scale(h,tD),i.invInertiaWorldSolve.vmult(n,tU),s.invInertiaWorldSolve.vmult(l,tG),t.multiplyVectors(tH,tU)+e.multiplyVectors(tD,tG)}computeGiMGt(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.invMassSolve,n=s.invMassSolve,r=i.invInertiaWorldSolve,l=s.invInertiaWorldSolve,a=o+n;return r.vmult(t.rotational,tY),a+=tY.dot(t.rotational),l.vmult(e.rotational,tY),a+=tY.dot(e.rotational)}addToWlambda(t){let e=this.jacobianElementA,i=this.jacobianElementB,s=this.bi,o=this.bj;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),o.vlambda.addScaledVector(o.invMassSolve*t,i.spatial,o.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,tX),s.wlambda.addScaledVector(t,tX,s.wlambda),o.invInertiaWorldSolve.vmult(i.rotational,tX),o.wlambda.addScaledVector(t,tX,o.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}t_.idCounter=0;let tH=new p,tD=new p,tU=new p,tG=new p,tY=new p,tX=new p;class t$ extends t_{constructor(t,e,i){void 0===i&&(i=1e6),super(t,e,0,i),this.restitution=0,this.ri=new p,this.rj=new p,this.ni=new p}computeB(t){let e=this.a,i=this.b,s=this.bi,o=this.bj,n=this.ri,r=this.rj,l=s.velocity,a=s.angularVelocity;s.force,s.torque;let h=o.velocity,d=o.angularVelocity;o.force,o.torque;let c=this.jacobianElementA,u=this.jacobianElementB,p=this.ni;n.cross(p,tK),r.cross(p,tZ),p.negate(c.spatial),tK.negate(c.rotational),u.spatial.copy(p),u.rotational.copy(tZ),tQ.copy(o.position),tQ.vadd(r,tQ),tQ.vsub(s.position,tQ),tQ.vsub(n,tQ);let y=p.dot(tQ),v=this.restitution+1,m=v*h.dot(p)-v*l.dot(p)+d.dot(tZ)-a.dot(tK);return-y*e-m*i-t*this.computeGiMf()}getImpactVelocityAlongNormal(){return this.bi.position.vadd(this.ri,t1),this.bj.position.vadd(this.rj,t2),this.bi.getVelocityAtWorldPoint(t1,tJ),this.bj.getVelocityAtWorldPoint(t2,t0),tJ.vsub(t0,t3),this.ni.dot(t3)}}let tK=new p,tZ=new p,tQ=new p,tJ=new p,t0=new p,t1=new p,t2=new p,t3=new p;class t5 extends tO{constructor(t,e,i,s,o){void 0===e&&(e=new p),void 0===s&&(s=new p),void 0===o&&(o=1e6),super(t,i),this.pivotA=e.clone(),this.pivotB=s.clone();let n=this.equationX=new t$(t,i),r=this.equationY=new t$(t,i),l=this.equationZ=new t$(t,i);this.equations.push(n,r,l),n.minForce=r.minForce=l.minForce=-o,n.maxForce=r.maxForce=l.maxForce=o,n.ni.set(1,0,0),r.ni.set(0,1,0),l.ni.set(0,0,1)}update(){let t=this.bodyA,e=this.bodyB,i=this.equationX,s=this.equationY,o=this.equationZ;t.quaternion.vmult(this.pivotA,i.ri),e.quaternion.vmult(this.pivotB,i.rj),s.ri.copy(i.ri),s.rj.copy(i.rj),o.ri.copy(i.ri),o.rj.copy(i.rj)}}class t6 extends t_{constructor(t,e,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6;super(t,e,-s,s),this.axisA=i.axisA?i.axisA.clone():new p(1,0,0),this.axisB=i.axisB?i.axisB.clone():new p(0,1,0),this.angle=void 0!==i.angle?i.angle:0}computeB(t){let e=this.a,i=this.b,s=this.axisA,o=this.axisB,n=this.jacobianElementA,r=this.jacobianElementB;s.cross(o,t4),o.cross(s,t7),n.rotational.copy(t7),r.rotational.copy(t4);let l=Math.cos(this.angle)-s.dot(o),a=this.computeGW();return-l*e-a*i-t*this.computeGiMf()}}let t4=new p,t7=new p;class t8 extends t_{constructor(t,e,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6;super(t,e,-s,s),this.axisA=i.axisA?i.axisA.clone():new p(1,0,0),this.axisB=i.axisB?i.axisB.clone():new p(0,1,0),this.maxAngle=Math.PI/2}computeB(t){let e=this.a,i=this.b,s=this.axisA,o=this.axisB,n=this.jacobianElementA,r=this.jacobianElementB;s.cross(o,t9),o.cross(s,et),n.rotational.copy(et),r.rotational.copy(t9);let l=Math.cos(this.maxAngle)-s.dot(o),a=this.computeGW();return-l*e-a*i-t*this.computeGiMf()}}let t9=new p,et=new p;class ee extends t5{constructor(t,e,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6;super(t,i.pivotA?i.pivotA.clone():new p,e,i.pivotB?i.pivotB.clone():new p,s),this.axisA=i.axisA?i.axisA.clone():new p,this.axisB=i.axisB?i.axisB.clone():new p,this.collideConnected=!!i.collideConnected,this.angle=void 0!==i.angle?i.angle:0;let o=this.coneEquation=new t6(t,e,i),n=this.twistEquation=new t8(t,e,i);this.twistAngle=void 0!==i.twistAngle?i.twistAngle:0,o.maxForce=0,o.minForce=-s,n.maxForce=0,n.minForce=-s,this.equations.push(o,n)}update(){let t=this.bodyA,e=this.bodyB,i=this.coneEquation,s=this.twistEquation;super.update(),t.vectorToWorldFrame(this.axisA,i.axisA),e.vectorToWorldFrame(this.axisB,i.axisB),this.axisA.tangents(s.axisA,s.axisA),t.vectorToWorldFrame(s.axisA,s.axisA),this.axisB.tangents(s.axisB,s.axisB),e.vectorToWorldFrame(s.axisB,s.axisB),i.angle=this.angle,s.maxAngle=this.twistAngle}}new p,new p;class ei extends tO{constructor(t,e,i,s){void 0===s&&(s=1e6),super(t,e),void 0===i&&(i=t.position.distanceTo(e.position)),this.distance=i;let o=this.distanceEquation=new t$(t,e);this.equations.push(o),o.minForce=-s,o.maxForce=s}update(){let t=this.bodyA,e=this.bodyB,i=this.distanceEquation,s=.5*this.distance,o=i.ni;e.position.vsub(t.position,o),o.normalize(),o.scale(s,i.ri),o.scale(-s,i.rj)}}class es extends t5{constructor(t,e,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6,o=new p,n=new p,r=new p;t.position.vadd(e.position,r),r.scale(.5,r),e.pointToLocalFrame(r,n),t.pointToLocalFrame(r,o),super(t,o,e,n,s),this.xA=t.vectorToLocalFrame(p.UNIT_X),this.xB=e.vectorToLocalFrame(p.UNIT_X),this.yA=t.vectorToLocalFrame(p.UNIT_Y),this.yB=e.vectorToLocalFrame(p.UNIT_Y),this.zA=t.vectorToLocalFrame(p.UNIT_Z),this.zB=e.vectorToLocalFrame(p.UNIT_Z);let l=this.rotationalEquation1=new t8(t,e,i),a=this.rotationalEquation2=new t8(t,e,i),h=this.rotationalEquation3=new t8(t,e,i);this.equations.push(l,a,h)}update(){let t=this.bodyA,e=this.bodyB;this.motorEquation;let i=this.rotationalEquation1,s=this.rotationalEquation2,o=this.rotationalEquation3;super.update(),t.vectorToWorldFrame(this.xA,i.axisA),e.vectorToWorldFrame(this.yB,i.axisB),t.vectorToWorldFrame(this.yA,s.axisA),e.vectorToWorldFrame(this.zB,s.axisB),t.vectorToWorldFrame(this.zA,o.axisA),e.vectorToWorldFrame(this.xB,o.axisB)}}new p,new p;class eo extends t_{constructor(t,e,i){void 0===i&&(i=1e6),super(t,e,-i,i),this.axisA=new p,this.axisB=new p,this.targetVelocity=0}computeB(t){this.a;let e=this.b;this.bi,this.bj;let i=this.axisA,s=this.axisB,o=this.jacobianElementA,n=this.jacobianElementB;o.rotational.copy(i),s.negate(n.rotational);let r=this.computeGW()-this.targetVelocity;return-r*e-t*this.computeGiMf()}}class en extends t5{constructor(t,e,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6;super(t,i.pivotA?i.pivotA.clone():new p,e,i.pivotB?i.pivotB.clone():new p,s),(this.axisA=i.axisA?i.axisA.clone():new p(1,0,0)).normalize(),(this.axisB=i.axisB?i.axisB.clone():new p(1,0,0)).normalize(),this.collideConnected=!!i.collideConnected;let o=this.rotationalEquation1=new t8(t,e,i),n=this.rotationalEquation2=new t8(t,e,i),r=this.motorEquation=new eo(t,e,s);r.enabled=!1,this.equations.push(o,n,r)}enableMotor(){this.motorEquation.enabled=!0}disableMotor(){this.motorEquation.enabled=!1}setMotorSpeed(t){this.motorEquation.targetVelocity=t}setMotorMaxForce(t){this.motorEquation.maxForce=t,this.motorEquation.minForce=-t}update(){let t=this.bodyA,e=this.bodyB,i=this.motorEquation,s=this.rotationalEquation1,o=this.rotationalEquation2,n=this.axisA,r=this.axisB;super.update(),t.quaternion.vmult(n,er),e.quaternion.vmult(r,el),er.tangents(s.axisA,o.axisA),s.axisB.copy(el),o.axisB.copy(el),this.motorEquation.enabled&&(t.quaternion.vmult(this.axisA,i.axisA),e.quaternion.vmult(this.axisB,i.axisB))}}let er=new p,el=new p;class ea extends t_{constructor(t,e,i){super(t,e,-i,i),this.ri=new p,this.rj=new p,this.t=new p}computeB(t){this.a;let e=this.b;this.bi,this.bj;let i=this.ri,s=this.rj,o=this.t;i.cross(o,eh),s.cross(o,ed);let n=this.jacobianElementA,r=this.jacobianElementB;o.negate(n.spatial),eh.negate(n.rotational),r.spatial.copy(o),r.rotational.copy(ed);let l=this.computeGW();return-l*e-t*this.computeGiMf()}}let eh=new p,ed=new p;class ec{constructor(t,e,i){i=tj.defaults(i,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=ec.idCounter++,this.materials=[t,e],this.friction=i.friction,this.restitution=i.restitution,this.contactEquationStiffness=i.contactEquationStiffness,this.contactEquationRelaxation=i.contactEquationRelaxation,this.frictionEquationStiffness=i.frictionEquationStiffness,this.frictionEquationRelaxation=i.frictionEquationRelaxation}}ec.idCounter=0;class eu{constructor(t){void 0===t&&(t={});let e="";"string"==typeof t&&(e=t,t={}),this.name=e,this.id=eu.idCounter++,this.friction=void 0!==t.friction?t.friction:-1,this.restitution=void 0!==t.restitution?t.restitution:-1}}eu.idCounter=0;class ep{constructor(t,e,i){void 0===i&&(i={}),this.restLength="number"==typeof i.restLength?i.restLength:1,this.stiffness=i.stiffness||100,this.damping=i.damping||1,this.bodyA=t,this.bodyB=e,this.localAnchorA=new p,this.localAnchorB=new p,i.localAnchorA&&this.localAnchorA.copy(i.localAnchorA),i.localAnchorB&&this.localAnchorB.copy(i.localAnchorB),i.worldAnchorA&&this.setWorldAnchorA(i.worldAnchorA),i.worldAnchorB&&this.setWorldAnchorB(i.worldAnchorB)}setWorldAnchorA(t){this.bodyA.pointToLocalFrame(t,this.localAnchorA)}setWorldAnchorB(t){this.bodyB.pointToLocalFrame(t,this.localAnchorB)}getWorldAnchorA(t){this.bodyA.pointToWorldFrame(this.localAnchorA,t)}getWorldAnchorB(t){this.bodyB.pointToWorldFrame(this.localAnchorB,t)}applyForce(){let t=this.stiffness,e=this.damping,i=this.restLength,s=this.bodyA,o=this.bodyB;this.getWorldAnchorA(ew),this.getWorldAnchorB(ex),ew.vsub(s.position,ef),ex.vsub(o.position,eb),ex.vsub(ew,ey);let n=ey.length();ev.copy(ey),ev.normalize(),o.velocity.vsub(s.velocity,em),o.angularVelocity.cross(eb,eE),em.vadd(eE,em),s.angularVelocity.cross(ef,eE),em.vsub(eE,em),ev.scale(-t*(n-i)-e*em.dot(ev),eg),s.force.vsub(eg,s.force),o.force.vadd(eg,o.force),ef.cross(eg,eA),eb.cross(eg,eB),s.torque.vsub(eA,s.torque),o.torque.vadd(eB,o.torque)}}let ey=new p,ev=new p,em=new p,eg=new p,ew=new p,ex=new p,ef=new p,eb=new p,eA=new p,eB=new p,eE=new p;class eS{constructor(t){void 0===t&&(t={}),t=tj.defaults(t,{chassisConnectionPointLocal:new p,chassisConnectionPointWorld:new p,directionLocal:new p,directionWorld:new p,axleLocal:new p,axleWorld:new p,suspensionRestLength:1,suspensionMaxLength:2,radius:1,suspensionStiffness:100,dampingCompression:10,dampingRelaxation:10,frictionSlip:10.5,forwardAcceleration:1,sideAcceleration:1,steering:0,rotation:0,deltaRotation:0,rollInfluence:.01,maxSuspensionForce:Number.MAX_VALUE,isFrontWheel:!0,clippedInvContactDotSuspension:1,suspensionRelativeVelocity:0,suspensionForce:0,slipInfo:0,skidInfo:0,suspensionLength:0,maxSuspensionTravel:1,useCustomSlidingRotationalSpeed:!1,customSlidingRotationalSpeed:-.1}),this.maxSuspensionTravel=t.maxSuspensionTravel,this.customSlidingRotationalSpeed=t.customSlidingRotationalSpeed,this.useCustomSlidingRotationalSpeed=t.useCustomSlidingRotationalSpeed,this.sliding=!1,this.chassisConnectionPointLocal=t.chassisConnectionPointLocal.clone(),this.chassisConnectionPointWorld=t.chassisConnectionPointWorld.clone(),this.directionLocal=t.directionLocal.clone(),this.directionWorld=t.directionWorld.clone(),this.axleLocal=t.axleLocal.clone(),this.axleWorld=t.axleWorld.clone(),this.suspensionRestLength=t.suspensionRestLength,this.suspensionMaxLength=t.suspensionMaxLength,this.radius=t.radius,this.suspensionStiffness=t.suspensionStiffness,this.dampingCompression=t.dampingCompression,this.dampingRelaxation=t.dampingRelaxation,this.frictionSlip=t.frictionSlip,this.forwardAcceleration=t.forwardAcceleration,this.sideAcceleration=t.sideAcceleration,this.steering=0,this.rotation=0,this.deltaRotation=0,this.rollInfluence=t.rollInfluence,this.maxSuspensionForce=t.maxSuspensionForce,this.engineForce=0,this.brake=0,this.isFrontWheel=t.isFrontWheel,this.clippedInvContactDotSuspension=1,this.suspensionRelativeVelocity=0,this.suspensionForce=0,this.slipInfo=0,this.skidInfo=0,this.suspensionLength=0,this.sideImpulse=0,this.forwardImpulse=0,this.raycastResult=new tl,this.worldTransform=new C,this.isInContact=!1}updateWheel(t){let e=this.raycastResult;if(this.isInContact){let i=e.hitNormalWorld.dot(e.directionWorld);e.hitPointWorld.vsub(t.position,eC),t.getVelocityAtWorldPoint(eC,ez);let s=e.hitNormalWorld.dot(ez);if(i>=-.1)this.suspensionRelativeVelocity=0,this.clippedInvContactDotSuspension=10;else{let t=-1/i;this.suspensionRelativeVelocity=s*t,this.clippedInvContactDotSuspension=t}}else e.suspensionLength=this.suspensionRestLength,this.suspensionRelativeVelocity=0,e.directionWorld.scale(-1,e.hitNormalWorld),this.clippedInvContactDotSuspension=1}}let ez=new p,eC=new p;class eF{constructor(t){this.chassisBody=t.chassisBody,this.wheelInfos=[],this.sliding=!1,this.world=null,this.indexRightAxis=void 0!==t.indexRightAxis?t.indexRightAxis:2,this.indexForwardAxis=void 0!==t.indexForwardAxis?t.indexForwardAxis:0,this.indexUpAxis=void 0!==t.indexUpAxis?t.indexUpAxis:1,this.constraints=[],this.preStepCallback=()=>{},this.currentVehicleSpeedKmHour=0,this.numWheelsOnGround=0}addWheel(t){void 0===t&&(t={});let e=new eS(t),i=this.wheelInfos.length;return this.wheelInfos.push(e),i}setSteeringValue(t,e){this.wheelInfos[e].steering=t}applyEngineForce(t,e){this.wheelInfos[e].engineForce=t}setBrake(t,e){this.wheelInfos[e].brake=t}addToWorld(t){t.addBody(this.chassisBody);let e=this;this.preStepCallback=()=>{e.updateVehicle(t.dt)},t.addEventListener("preStep",this.preStepCallback),this.world=t}getVehicleAxisWorld(t,e){e.set(+(0===t),+(1===t),+(2===t)),this.chassisBody.vectorToWorldFrame(e,e)}updateVehicle(t){let e=this.wheelInfos,i=e.length,s=this.chassisBody;for(let t=0;t<i;t++)this.updateWheelTransform(t);this.currentVehicleSpeedKmHour=3.6*s.velocity.length();let o=new p;this.getVehicleAxisWorld(this.indexForwardAxis,o),0>o.dot(s.velocity)&&(this.currentVehicleSpeedKmHour*=-1);for(let t=0;t<i;t++)this.castRay(e[t]);this.updateSuspension(t);let n=new p,r=new p;for(let o=0;o<i;o++){let i=e[o],l=i.suspensionForce;l>i.maxSuspensionForce&&(l=i.maxSuspensionForce),i.raycastResult.hitNormalWorld.scale(l*t,n),i.raycastResult.hitPointWorld.vsub(s.position,r),s.applyImpulse(n,r)}this.updateFriction(t);let l=new p,a=new p,h=new p;for(let o=0;o<i;o++){let i=e[o];s.getVelocityAtWorldPoint(i.chassisConnectionPointWorld,h);let n=1;if(1===this.indexUpAxis&&(n=-1),i.isInContact){this.getVehicleAxisWorld(this.indexForwardAxis,a);let e=a.dot(i.raycastResult.hitNormalWorld);i.raycastResult.hitNormalWorld.scale(e,l),a.vsub(l,a),i.deltaRotation=n*a.dot(h)*t/i.radius}(i.sliding||!i.isInContact)&&0!==i.engineForce&&i.useCustomSlidingRotationalSpeed&&(i.deltaRotation=(i.engineForce>0?1:-1)*i.customSlidingRotationalSpeed*t),Math.abs(i.brake)>Math.abs(i.engineForce)&&(i.deltaRotation=0),i.rotation+=i.deltaRotation,i.deltaRotation*=.99}}updateSuspension(t){let e=this.chassisBody.mass,i=this.wheelInfos,s=i.length;for(let t=0;t<s;t++){let s=i[t];if(s.isInContact){let t,i,o=s.suspensionRestLength-s.suspensionLength;t=s.suspensionStiffness*o*s.clippedInvContactDotSuspension;let n=s.suspensionRelativeVelocity;t-=(n<0?s.dampingCompression:s.dampingRelaxation)*n,s.suspensionForce=t*e,s.suspensionForce<0&&(s.suspensionForce=0)}else s.suspensionForce=0}}removeFromWorld(t){this.constraints,t.removeBody(this.chassisBody),t.removeEventListener("preStep",this.preStepCallback),this.world=null}castRay(t){this.updateWheelTransformWorld(t);let e=this.chassisBody,i=-1,s=t.suspensionRestLength+t.radius;t.directionWorld.scale(s,eI);let o=t.chassisConnectionPointWorld;o.vadd(eI,eP);let n=t.raycastResult;n.reset();let r=e.collisionResponse;e.collisionResponse=!1,this.world.rayTest(o,eP,n),e.collisionResponse=r;let l=n.body;if(t.raycastResult.groundObject=0,l){i=n.distance,t.raycastResult.hitNormalWorld=n.hitNormalWorld,t.isInContact=!0,t.suspensionLength=n.distance-t.radius;let s=t.suspensionRestLength-t.maxSuspensionTravel,o=t.suspensionRestLength+t.maxSuspensionTravel;t.suspensionLength<s&&(t.suspensionLength=s),t.suspensionLength>o&&(t.suspensionLength=o,t.raycastResult.reset());let r=t.raycastResult.hitNormalWorld.dot(t.directionWorld),l=new p;e.getVelocityAtWorldPoint(t.raycastResult.hitPointWorld,l);let a=t.raycastResult.hitNormalWorld.dot(l);if(r>=-.1)t.suspensionRelativeVelocity=0,t.clippedInvContactDotSuspension=10;else{let e=-1/r;t.suspensionRelativeVelocity=a*e,t.clippedInvContactDotSuspension=e}}else t.suspensionLength=t.suspensionRestLength+0*t.maxSuspensionTravel,t.suspensionRelativeVelocity=0,t.directionWorld.scale(-1,t.raycastResult.hitNormalWorld),t.clippedInvContactDotSuspension=1;return i}updateWheelTransformWorld(t){t.isInContact=!1;let e=this.chassisBody;e.pointToWorldFrame(t.chassisConnectionPointLocal,t.chassisConnectionPointWorld),e.vectorToWorldFrame(t.directionLocal,t.directionWorld),e.vectorToWorldFrame(t.axleLocal,t.axleWorld)}updateWheelTransform(t){let e=this.wheelInfos[t];this.updateWheelTransformWorld(e),e.directionLocal.scale(-1,eM),eR.copy(e.axleLocal),eM.cross(eR,eT),eT.normalize(),eR.normalize();let i=e.steering,s=new A;s.setFromAxisAngle(eM,i);let o=new A;o.setFromAxisAngle(eR,e.rotation);let n=e.worldTransform.quaternion;this.chassisBody.quaternion.mult(s,n),n.mult(o,n),n.normalize();let r=e.worldTransform.position;r.copy(e.directionWorld),r.scale(e.suspensionLength,r),r.vadd(e.chassisConnectionPointWorld,r)}getWheelTransformWorld(t){return this.wheelInfos[t].worldTransform}updateFriction(t){let e=this.wheelInfos,i=e.length,s=this.chassisBody;this.numWheelsOnGround=0;for(let t=0;t<i;t++){let i=e[t];i.raycastResult.body&&this.numWheelsOnGround++,i.sideImpulse=0,i.forwardImpulse=0,eW[t]||(eW[t]=new p),eL[t]||(eL[t]=new p)}for(let t=0;t<i;t++){let i=e[t],o=i.raycastResult.body;if(o){let e=eL[t];this.getWheelTransformWorld(t).vectorToWorldFrame(eq[this.indexRightAxis],e);let n=i.raycastResult.hitNormalWorld,r=e.dot(n);n.scale(r,eN),e.vsub(eN,e),e.normalize(),n.cross(e,eW[t]),eW[t].normalize(),i.sideImpulse=function(t,e,i,s,o){if(o.lengthSquared()>1.1)return 0;t.getVelocityAtWorldPoint(e,eY),i.getVelocityAtWorldPoint(s,eX),eY.vsub(eX,e$);let n=o.dot(e$);return -.2*n*(1/(t.invMass+i.invMass))}(s,i.raycastResult.hitPointWorld,o,i.raycastResult.hitPointWorld,e),i.sideImpulse*=eV}}this.sliding=!1;for(let o=0;o<i;o++){let i=e[o],n=i.raycastResult.body,r=0;if(i.slipInfo=1,n){let e=i.brake?i.brake:0;r=function(t,e,i,s,o){let n=0;t.getVelocityAtWorldPoint(i,ej),e.getVelocityAtWorldPoint(i,eO),ej.vsub(eO,ek);let r=s.dot(ek),l=eG(t,i,s);return o<(n=-(1/(l+eG(e,i,s))*r))&&(n=o),n<-o&&(n=-o),n}(s,n,i.raycastResult.hitPointWorld,eW[o],e)+i.engineForce*t;let l=e/r;i.slipInfo*=l}if(i.forwardImpulse=0,i.skidInfo=1,n){i.skidInfo=1;let e=i.suspensionForce*t*i.frictionSlip,s=e*e;i.forwardImpulse=r;let o=.5*i.forwardImpulse/i.forwardAcceleration,n=i.sideImpulse/i.sideAcceleration,l=o*o+n*n;if(i.sliding=!1,l>s){this.sliding=!0,i.sliding=!0;let t=e/Math.sqrt(l);i.skidInfo*=t}}}if(this.sliding)for(let t=0;t<i;t++){let i=e[t];0!==i.sideImpulse&&i.skidInfo<1&&(i.forwardImpulse*=i.skidInfo,i.sideImpulse*=i.skidInfo)}for(let t=0;t<i;t++){let i=e[t],o=new p;if(i.raycastResult.hitPointWorld.vsub(s.position,o),0!==i.forwardImpulse){let e=new p;eW[t].scale(i.forwardImpulse,e),s.applyImpulse(e,o)}if(0!==i.sideImpulse){let e=i.raycastResult.body,n=new p;i.raycastResult.hitPointWorld.vsub(e.position,n);let r=new p;eL[t].scale(i.sideImpulse,r),s.vectorToLocalFrame(o,o),o["xyz"[this.indexUpAxis]]*=i.rollInfluence,s.vectorToWorldFrame(o,o),s.applyImpulse(r,o),r.scale(-1,r),e.applyImpulse(r,n)}}}}new p,new p,new p;let eM=new p,eR=new p,eT=new p;new th,new p;let eI=new p,eP=new p,eq=[new p(1,0,0),new p(0,1,0),new p(0,0,1)],eN=new p,eL=[],eW=[],eV=1,ej=new p,eO=new p,ek=new p,e_=new p,eH=new p,eD=new p,eU=new p;function eG(t,e,i){return e.vsub(t.position,e_),e_.cross(i,eH),t.invInertiaWorld.vmult(eH,eU),eU.cross(e_,eD),t.invMass+i.dot(eD)}let eY=new p,eX=new p,e$=new p;class eK extends z{constructor(t){if(super({type:z.types.SPHERE}),this.radius=void 0!==t?t:1,this.radius<0)throw Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(t,e){void 0===e&&(e=new p);let i=2*t*this.radius*this.radius/5;return e.x=i,e.y=i,e.z=i,e}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(t,e,i,s){let o=this.radius,n=["x","y","z"];for(let e=0;e<n.length;e++){let r=n[e];i[r]=t[r]-o,s[r]=t[r]+o}}}class eZ{constructor(t){void 0===t&&(t={}),this.wheelBodies=[],this.coordinateSystem=void 0!==t.coordinateSystem?t.coordinateSystem.clone():new p(1,2,3),t.chassisBody?this.chassisBody=t.chassisBody:this.chassisBody=new j({mass:1,shape:new q(new p(5,.5,2))}),this.constraints=[],this.wheelAxes=[],this.wheelForces=[]}addWheel(t){let e;void 0===t&&(t={}),e=t.body?t.body:new j({mass:1,shape:new eK(1.2)}),this.wheelBodies.push(e),this.wheelForces.push(0);let i=void 0!==t.position?t.position.clone():new p,s=new p;this.chassisBody.pointToWorldFrame(i,s),e.position.set(s.x,s.y,s.z);let o=void 0!==t.axis?t.axis.clone():new p(0,0,1);this.wheelAxes.push(o);let n=new en(this.chassisBody,e,{pivotA:i,axisA:o,pivotB:p.ZERO,axisB:o,collideConnected:!1});return this.constraints.push(n),this.wheelBodies.length-1}setSteeringValue(t,e){let i=this.wheelAxes[e],s=Math.cos(t),o=Math.sin(t),n=i.x,r=i.z;this.constraints[e].axisA.set(-s*n+o*r,0,o*n+s*r)}setMotorSpeed(t,e){let i=this.constraints[e];i.enableMotor(),i.motorTargetVelocity=t}disableMotor(t){this.constraints[t].disableMotor()}setWheelForce(t,e){this.wheelForces[e]=t}applyWheelForce(t,e){let i=this.wheelAxes[e],s=this.wheelBodies[e],o=s.torque;i.scale(t,eQ),s.vectorToWorldFrame(eQ,eQ),o.vadd(eQ,o)}addToWorld(t){let e=this.constraints,i=this.wheelBodies.concat([this.chassisBody]);for(let e=0;e<i.length;e++)t.addBody(i[e]);for(let i=0;i<e.length;i++)t.addConstraint(e[i]);t.addEventListener("preStep",this._update.bind(this))}_update(){let t=this.wheelForces;for(let e=0;e<t.length;e++)this.applyWheelForce(t[e],e)}removeFromWorld(t){let e=this.constraints,i=this.wheelBodies.concat([this.chassisBody]);for(let e=0;e<i.length;e++)t.removeBody(i[e]);for(let i=0;i<e.length;i++)t.removeConstraint(e[i])}getWheelSpeed(t){let e=this.wheelAxes[t],i=this.wheelBodies[t].angularVelocity;return this.chassisBody.vectorToWorldFrame(e,eJ),i.dot(eJ)}}let eQ=new p,eJ=new p;class e0{constructor(){this.particles=[],this.density=1,this.smoothingRadius=1,this.speedOfSound=1,this.viscosity=.01,this.eps=1e-6,this.pressures=[],this.densities=[],this.neighbors=[]}add(t){this.particles.push(t),this.neighbors.length<this.particles.length&&this.neighbors.push([])}remove(t){let e=this.particles.indexOf(t);-1!==e&&(this.particles.splice(e,1),this.neighbors.length>this.particles.length&&this.neighbors.pop())}getNeighbors(t,e){let i=this.particles.length,s=t.id,o=this.smoothingRadius*this.smoothingRadius;for(let n=0;n!==i;n++){let i=this.particles[n];i.position.vsub(t.position,e1),s!==i.id&&e1.lengthSquared()<o&&e.push(i)}}update(){let t=this.particles.length,e=this.speedOfSound,i=this.eps;for(let i=0;i!==t;i++){let t=this.particles[i],s=this.neighbors[i];s.length=0,this.getNeighbors(t,s),s.push(this.particles[i]);let o=s.length,n=0;for(let e=0;e!==o;e++){t.position.vsub(s[e].position,e2);let i=e2.length(),o=this.w(i);n+=s[e].mass*o}this.densities[i]=n,this.pressures[i]=e*e*(this.densities[i]-this.density)}for(let e=0;e!==t;e++){let t,s,o=this.particles[e];e3.set(0,0,0),e5.set(0,0,0);let n=this.neighbors[e],r=n.length;for(let l=0;l!==r;l++){let r=n[l];o.position.vsub(r.position,e4);let a=e4.length();t=-r.mass*(this.pressures[e]/(this.densities[e]*this.densities[e]+i)+this.pressures[l]/(this.densities[l]*this.densities[l]+i)),this.gradw(e4,e6),e6.scale(t,e6),e3.vadd(e6,e3),r.velocity.vsub(o.velocity,e7),e7.scale(1/(1e-4+this.densities[e]*this.densities[l])*this.viscosity*r.mass,e7),s=this.nablaw(a),e7.scale(s,e7),e5.vadd(e7,e5)}e5.scale(o.mass,e5),e3.scale(o.mass,e3),o.force.vadd(e5,o.force),o.force.vadd(e3,o.force)}}w(t){let e=this.smoothingRadius;return 315/(64*Math.PI*e**9)*(e*e-t*t)**3}gradw(t,e){let i=t.length(),s=this.smoothingRadius;t.scale(945/(32*Math.PI*s**9)*(s*s-i*i)**2,e)}nablaw(t){let e=this.smoothingRadius;return 945/(32*Math.PI*e**9)*(e*e-t*t)*(7*t*t-3*e*e)}}let e1=new p,e2=new p,e3=new p,e5=new p,e6=new p,e4=new p,e7=new p;class e8 extends M{constructor(t,e,i,s){if(void 0===t&&(t=1),void 0===e&&(e=1),void 0===i&&(i=1),void 0===s&&(s=8),t<0)throw Error("The cylinder radiusTop cannot be negative.");if(e<0)throw Error("The cylinder radiusBottom cannot be negative.");let o=s,n=[],r=[],l=[],a=[],h=[],d=Math.cos,c=Math.sin;n.push(new p(-e*c(0),-(.5*i),e*d(0))),a.push(0),n.push(new p(-t*c(0),.5*i,t*d(0))),h.push(1);for(let s=0;s<o;s++){let u=2*Math.PI/o*(s+1),y=2*Math.PI/o*(s+.5);s<o-1?(n.push(new p(-e*c(u),-(.5*i),e*d(u))),a.push(2*s+2),n.push(new p(-t*c(u),.5*i,t*d(u))),h.push(2*s+3),l.push([2*s,2*s+1,2*s+3,2*s+2])):l.push([2*s,2*s+1,1,0]),(o%2==1||s<o/2)&&r.push(new p(-c(y),0,d(y)))}l.push(a),r.push(new p(0,1,0));let u=[];for(let t=0;t<h.length;t++)u.push(h[h.length-t-1]);l.push(u),super({vertices:n,faces:l,axes:r}),this.type=z.types.CYLINDER,this.radiusTop=t,this.radiusBottom=e,this.height=i,this.numSegments=s}}class e9 extends z{constructor(){super({type:z.types.PARTICLE})}calculateLocalInertia(t,e){return void 0===e&&(e=new p),e.set(0,0,0),e}volume(){return 0}updateBoundingSphereRadius(){this.boundingSphereRadius=0}calculateWorldAABB(t,e,i,s){i.copy(t),s.copy(t)}}class it extends z{constructor(){super({type:z.types.PLANE}),this.worldNormal=new p,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){let e=this.worldNormal;e.set(0,0,1),t.vmult(e,e),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,e){return void 0===e&&(e=new p),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,i,s){ie.set(0,0,1),e.vmult(ie,ie);let o=Number.MAX_VALUE;i.set(-o,-o,-o),s.set(o,o,o),1===ie.x?s.x=t.x:-1===ie.x&&(i.x=t.x),1===ie.y?s.y=t.y:-1===ie.y&&(i.y=t.y),1===ie.z?s.z=t.z:-1===ie.z&&(i.z=t.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}let ie=new p;class ii extends z{constructor(t,e){void 0===e&&(e={}),e=tj.defaults(e,{maxValue:null,minValue:null,elementSize:1}),super({type:z.types.HEIGHTFIELD}),this.data=t,this.maxValue=e.maxValue,this.minValue=e.minValue,this.elementSize=e.elementSize,null===e.minValue&&this.updateMinValue(),null===e.maxValue&&this.updateMaxValue(),this.cacheEnabled=!0,this.pillarConvex=new M,this.pillarOffset=new p,this.updateBoundingSphereRadius(),this._cachedPillars={}}update(){this._cachedPillars={}}updateMinValue(){let t=this.data,e=t[0][0];for(let i=0;i!==t.length;i++)for(let s=0;s!==t[i].length;s++){let o=t[i][s];o<e&&(e=o)}this.minValue=e}updateMaxValue(){let t=this.data,e=t[0][0];for(let i=0;i!==t.length;i++)for(let s=0;s!==t[i].length;s++){let o=t[i][s];o>e&&(e=o)}this.maxValue=e}setHeightValueAtIndex(t,e,i){this.data[t][e]=i,this.clearCachedConvexTrianglePillar(t,e,!1),t>0&&(this.clearCachedConvexTrianglePillar(t-1,e,!0),this.clearCachedConvexTrianglePillar(t-1,e,!1)),e>0&&(this.clearCachedConvexTrianglePillar(t,e-1,!0),this.clearCachedConvexTrianglePillar(t,e-1,!1)),e>0&&t>0&&this.clearCachedConvexTrianglePillar(t-1,e-1,!0)}getRectMinMax(t,e,i,s,o){void 0===o&&(o=[]);let n=this.data,r=this.minValue;for(let o=t;o<=i;o++)for(let t=e;t<=s;t++){let e=n[o][t];e>r&&(r=e)}o[0]=this.minValue,o[1]=r}getIndexOfPosition(t,e,i,s){let o=this.elementSize,n=this.data,r=Math.floor(t/o),l=Math.floor(e/o);return i[0]=r,i[1]=l,s&&(r<0&&(r=0),l<0&&(l=0),r>=n.length-1&&(r=n.length-1),l>=n[0].length-1&&(l=n[0].length-1)),!(r<0)&&!(l<0)&&!(r>=n.length-1)&&!(l>=n[0].length-1)}getTriangleAt(t,e,i,s,o,n){this.getIndexOfPosition(t,e,is,i);let r=is[0],l=is[1],a=this.data;i&&(r=Math.min(a.length-2,Math.max(0,r)),l=Math.min(a[0].length-2,Math.max(0,l)));let h=this.elementSize,d=(t/h-r)**2+(e/h-l)**2>(t/h-(r+1))**2+(e/h-(l+1))**2;return this.getTriangle(r,l,d,s,o,n),d}getNormalAt(t,e,i,s){this.getTriangleAt(t,e,i,ih,id,ic),id.vsub(ih,iu),ic.vsub(ih,ip),iu.cross(ip,s),s.normalize()}getAabbAtIndex(t,e,i){let{lowerBound:s,upperBound:o}=i,n=this.data,r=this.elementSize;s.set(t*r,e*r,n[t][e]),o.set((t+1)*r,(e+1)*r,n[t+1][e+1])}getHeightAt(t,e,i){var s,o,n,r,l,a,h,d,c;let u=this.data;this.getIndexOfPosition(t,e,is,i);let p=is[0],y=is[1];i&&(p=Math.min(u.length-2,Math.max(0,p)),y=Math.min(u[0].length-2,Math.max(0,y)));let v=this.getTriangleAt(t,e,i,ir,il,ia);return(s=t,o=e,n=ir.x,r=ir.y,l=il.x,a=il.y,h=ia.x,d=ia.y,(c=io).x=((a-d)*(s-h)+(h-l)*(o-d))/((a-d)*(n-h)+(h-l)*(r-d)),c.y=((d-r)*(s-h)+(n-h)*(o-d))/((a-d)*(n-h)+(h-l)*(r-d)),c.z=1-c.x-c.y,v)?u[p+1][y+1]*io.x+u[p][y+1]*io.y+u[p+1][y]*io.z:u[p][y]*io.x+u[p+1][y]*io.y+u[p][y+1]*io.z}getCacheConvexTrianglePillarKey(t,e,i){return`${t}_${e}_${+!!i}`}getCachedConvexTrianglePillar(t,e,i){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(t,e,i)]}setCachedConvexTrianglePillar(t,e,i,s,o){this._cachedPillars[this.getCacheConvexTrianglePillarKey(t,e,i)]={convex:s,offset:o}}clearCachedConvexTrianglePillar(t,e,i){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(t,e,i)]}getTriangle(t,e,i,s,o,n){let r=this.data,l=this.elementSize;i?(s.set((t+1)*l,(e+1)*l,r[t+1][e+1]),o.set(t*l,(e+1)*l,r[t][e+1]),n.set((t+1)*l,e*l,r[t+1][e])):(s.set(t*l,e*l,r[t][e]),o.set((t+1)*l,e*l,r[t+1][e]),n.set(t*l,(e+1)*l,r[t][e+1]))}getConvexTrianglePillar(t,e,i){let s=this.pillarConvex,o=this.pillarOffset;if(this.cacheEnabled){let n=this.getCachedConvexTrianglePillar(t,e,i);if(n){this.pillarConvex=n.convex,this.pillarOffset=n.offset;return}s=new M,o=new p,this.pillarConvex=s,this.pillarOffset=o}let n=this.data,r=this.elementSize,l=s.faces;s.vertices.length=6;for(let t=0;t<6;t++)s.vertices[t]||(s.vertices[t]=new p);l.length=5;for(let t=0;t<5;t++)l[t]||(l[t]=[]);let a=s.vertices,h=(Math.min(n[t][e],n[t+1][e],n[t][e+1],n[t+1][e+1])-this.minValue)/2+this.minValue;i?(o.set((t+.75)*r,(e+.75)*r,h),a[0].set(.25*r,.25*r,n[t+1][e+1]-h),a[1].set(-.75*r,.25*r,n[t][e+1]-h),a[2].set(.25*r,-.75*r,n[t+1][e]-h),a[3].set(.25*r,.25*r,-Math.abs(h)-1),a[4].set(-.75*r,.25*r,-Math.abs(h)-1),a[5].set(.25*r,-.75*r,-Math.abs(h)-1),l[0][0]=0,l[0][1]=1,l[0][2]=2,l[1][0]=5,l[1][1]=4,l[1][2]=3,l[2][0]=2,l[2][1]=5,l[2][2]=3,l[2][3]=0,l[3][0]=3,l[3][1]=4,l[3][2]=1,l[3][3]=0,l[4][0]=1,l[4][1]=4,l[4][2]=5,l[4][3]=2):(o.set((t+.25)*r,(e+.25)*r,h),a[0].set(-.25*r,-.25*r,n[t][e]-h),a[1].set(.75*r,-.25*r,n[t+1][e]-h),a[2].set(-.25*r,.75*r,n[t][e+1]-h),a[3].set(-.25*r,-.25*r,-Math.abs(h)-1),a[4].set(.75*r,-.25*r,-Math.abs(h)-1),a[5].set(-.25*r,.75*r,-Math.abs(h)-1),l[0][0]=0,l[0][1]=1,l[0][2]=2,l[1][0]=5,l[1][1]=4,l[1][2]=3,l[2][0]=0,l[2][1]=2,l[2][2]=5,l[2][3]=3,l[3][0]=1,l[3][1]=0,l[3][2]=3,l[3][3]=4,l[4][0]=4,l[4][1]=5,l[4][2]=2,l[4][3]=1),s.computeNormals(),s.computeEdges(),s.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(t,e,i,s,o)}calculateLocalInertia(t,e){return void 0===e&&(e=new p),e.set(0,0,0),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,i,s){i.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),s.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}updateBoundingSphereRadius(){let t=this.data,e=this.elementSize;this.boundingSphereRadius=new p(t.length*e,t[0].length*e,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).length()}setHeightsFromImage(t,e){let{x:i,z:s,y:o}=e,n=document.createElement("canvas");n.width=t.width,n.height=t.height;let r=n.getContext("2d");r.drawImage(t,0,0);let l=r.getImageData(0,0,t.width,t.height),a=this.data;a.length=0,this.elementSize=Math.abs(i)/l.width;for(let t=0;t<l.height;t++){let e=[];for(let o=0;o<l.width;o++){let n=l.data[(t*l.height+o)*4],r=(n+l.data[(t*l.height+o)*4+1]+l.data[(t*l.height+o)*4+2])/4/255*s;i<0?e.push(r):e.unshift(r)}o<0?a.unshift(e):a.push(e)}this.updateMaxValue(),this.updateMinValue(),this.update()}}let is=[],io=new p,ir=new p,il=new p,ia=new p,ih=new p,id=new p,ic=new p,iu=new p,ip=new p;class iy{constructor(t){void 0===t&&(t={}),this.root=t.root||null,this.aabb=t.aabb?t.aabb.clone():new g,this.data=[],this.children=[]}reset(){this.children.length=this.data.length=0}insert(t,e,i){void 0===i&&(i=0);let s=this.data;if(!this.aabb.contains(t))return!1;let o=this.children,n=this.maxDepth||this.root.maxDepth;if(i<n){let s=!1;o.length||(this.subdivide(),s=!0);for(let s=0;8!==s;s++)if(o[s].insert(t,e,i+1))return!0;s&&(o.length=0)}return s.push(e),!0}subdivide(){let t=this.aabb,e=t.lowerBound,i=t.upperBound,s=this.children;s.push(new iy({aabb:new g({lowerBound:new p(0,0,0)})}),new iy({aabb:new g({lowerBound:new p(1,0,0)})}),new iy({aabb:new g({lowerBound:new p(1,1,0)})}),new iy({aabb:new g({lowerBound:new p(1,1,1)})}),new iy({aabb:new g({lowerBound:new p(0,1,1)})}),new iy({aabb:new g({lowerBound:new p(0,0,1)})}),new iy({aabb:new g({lowerBound:new p(1,0,1)})}),new iy({aabb:new g({lowerBound:new p(0,1,0)})})),i.vsub(e,im),im.scale(.5,im);let o=this.root||this;for(let t=0;8!==t;t++){let i=s[t];i.root=o;let n=i.aabb.lowerBound;n.x*=im.x,n.y*=im.y,n.z*=im.z,n.vadd(e,n),n.vadd(im,i.aabb.upperBound)}}aabbQuery(t,e){this.data,this.children;let i=[this];for(;i.length;){let s=i.pop();s.aabb.overlaps(t)&&Array.prototype.push.apply(e,s.data),Array.prototype.push.apply(i,s.children)}return e}rayQuery(t,e,i){return t.getAABB(ig),ig.toLocalFrame(e,ig),this.aabbQuery(ig,i),i}removeEmptyNodes(){for(let t=this.children.length-1;t>=0;t--)this.children[t].removeEmptyNodes(),this.children[t].children.length||this.children[t].data.length||this.children.splice(t,1)}}class iv extends iy{constructor(t,e){void 0===e&&(e={}),super({root:null,aabb:t}),this.maxDepth=void 0!==e.maxDepth?e.maxDepth:8}}let im=new p,ig=new g;class iw extends z{constructor(t,e){super({type:z.types.TRIMESH}),this.vertices=new Float32Array(t),this.indices=new Int16Array(e),this.normals=new Float32Array(e.length),this.aabb=new g,this.edges=null,this.scale=new p(1,1,1),this.tree=new iv,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}updateTree(){let t=this.tree;t.reset(),t.aabb.copy(this.aabb);let e=this.scale;t.aabb.lowerBound.x*=1/e.x,t.aabb.lowerBound.y*=1/e.y,t.aabb.lowerBound.z*=1/e.z,t.aabb.upperBound.x*=1/e.x,t.aabb.upperBound.y*=1/e.y,t.aabb.upperBound.z*=1/e.z;let i=new g,s=new p,o=new p,n=new p,r=[s,o,n];for(let e=0;e<this.indices.length/3;e++){let l=3*e;this._getUnscaledVertex(this.indices[l],s),this._getUnscaledVertex(this.indices[l+1],o),this._getUnscaledVertex(this.indices[l+2],n),i.setFromPoints(r),t.insert(i,e)}t.removeEmptyNodes()}getTrianglesInAABB(t,e){ib.copy(t);let i=this.scale,s=i.x,o=i.y,n=i.z,r=ib.lowerBound,l=ib.upperBound;return r.x/=s,r.y/=o,r.z/=n,l.x/=s,l.y/=o,l.z/=n,this.tree.aabbQuery(ib,e)}setScale(t){let e=this.scale.x===this.scale.y&&this.scale.y===this.scale.z,i=t.x===t.y&&t.y===t.z;e&&i||this.updateNormals(),this.scale.copy(t),this.updateAABB(),this.updateBoundingSphereRadius()}updateNormals(){let t=this.normals;for(let e=0;e<this.indices.length/3;e++){let i=3*e,s=this.indices[i],o=this.indices[i+1],n=this.indices[i+2];this.getVertex(s,iz),this.getVertex(o,iC),this.getVertex(n,iF),iw.computeNormal(iC,iz,iF,ix),t[i]=ix.x,t[i+1]=ix.y,t[i+2]=ix.z}}updateEdges(){let t={},e=(e,i)=>{t[e<i?`${e}_${i}`:`${i}_${e}`]=!0};for(let t=0;t<this.indices.length/3;t++){let i=3*t,s=this.indices[i],o=this.indices[i+1],n=this.indices[i+2];e(s,o),e(o,n),e(n,s)}let i=Object.keys(t);this.edges=new Int16Array(2*i.length);for(let t=0;t<i.length;t++){let e=i[t].split("_");this.edges[2*t]=parseInt(e[0],10),this.edges[2*t+1]=parseInt(e[1],10)}}getEdgeVertex(t,e,i){let s=this.edges[2*t+ +!!e];this.getVertex(s,i)}getEdgeVector(t,e){this.getEdgeVertex(t,0,iA),this.getEdgeVertex(t,1,iB),iB.vsub(iA,e)}static computeNormal(t,e,i,s){e.vsub(t,iS),i.vsub(e,iE),iE.cross(iS,s),s.isZero()||s.normalize()}getVertex(t,e){let i=this.scale;return this._getUnscaledVertex(t,e),e.x*=i.x,e.y*=i.y,e.z*=i.z,e}_getUnscaledVertex(t,e){let i=3*t,s=this.vertices;return e.set(s[i],s[i+1],s[i+2])}getWorldVertex(t,e,i,s){return this.getVertex(t,s),C.pointToWorldFrame(e,i,s,s),s}getTriangleVertices(t,e,i,s){let o=3*t;this.getVertex(this.indices[o],e),this.getVertex(this.indices[o+1],i),this.getVertex(this.indices[o+2],s)}getNormal(t,e){let i=3*t;return e.set(this.normals[i],this.normals[i+1],this.normals[i+2])}calculateLocalInertia(t,e){this.computeLocalAABB(iM);let i=iM.upperBound.x-iM.lowerBound.x,s=iM.upperBound.y-iM.lowerBound.y,o=iM.upperBound.z-iM.lowerBound.z;return e.set(1/12*t*(2*s*2*s+2*o*2*o),1/12*t*(2*i*2*i+2*o*2*o),1/12*t*(2*s*2*s+2*i*2*i))}computeLocalAABB(t){let e=t.lowerBound,i=t.upperBound,s=this.vertices.length;this.vertices,this.getVertex(0,iR),e.copy(iR),i.copy(iR);for(let t=0;t!==s;t++)this.getVertex(t,iR),iR.x<e.x?e.x=iR.x:iR.x>i.x&&(i.x=iR.x),iR.y<e.y?e.y=iR.y:iR.y>i.y&&(i.y=iR.y),iR.z<e.z?e.z=iR.z:iR.z>i.z&&(i.z=iR.z)}updateAABB(){this.computeLocalAABB(this.aabb)}updateBoundingSphereRadius(){let t=0,e=this.vertices,i=new p;for(let s=0,o=e.length/3;s!==o;s++){this.getVertex(s,i);let e=i.lengthSquared();e>t&&(t=e)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,i,s){iT.position=t,iT.quaternion=e,this.aabb.toWorldFrame(iT,iI),i.copy(iI.lowerBound),s.copy(iI.upperBound)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}static createTorus(t,e,i,s,o){void 0===t&&(t=1),void 0===e&&(e=.5),void 0===i&&(i=8),void 0===s&&(s=6),void 0===o&&(o=2*Math.PI);let n=[],r=[];for(let r=0;r<=i;r++)for(let l=0;l<=s;l++){let a=l/s*o,h=r/i*Math.PI*2,d=(t+e*Math.cos(h))*Math.cos(a),c=(t+e*Math.cos(h))*Math.sin(a),u=e*Math.sin(h);n.push(d,c,u)}for(let t=1;t<=i;t++)for(let e=1;e<=s;e++){let i=(s+1)*t+e-1,o=(s+1)*(t-1)+e-1,n=(s+1)*(t-1)+e,l=(s+1)*t+e;r.push(i,o,l),r.push(o,n,l)}return new iw(n,r)}}let ix=new p,ib=new g,iA=new p,iB=new p,iE=new p,iS=new p,iz=new p,iC=new p,iF=new p,iM=new g,iR=new p,iT=new C,iI=new g;class iP{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){!t.enabled||t.bi.isTrigger||t.bj.isTrigger||this.equations.push(t)}removeEquation(t){let e=this.equations,i=e.indexOf(t);-1!==i&&e.splice(i,1)}removeAllEquations(){this.equations.length=0}}class iq extends iP{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let i,s,o,n,r,l=0,a=this.iterations,h=this.tolerance*this.tolerance,d=this.equations,c=d.length,u=e.bodies,p=u.length;if(0!==c)for(let t=0;t!==p;t++)u[t].updateSolveMassProperties();iL.length=c,iW.length=c,iN.length=c;for(let e=0;e!==c;e++){let i=d[e];iN[e]=0,iW[e]=i.computeB(t),iL[e]=1/i.computeC()}if(0!==c){for(let t=0;t!==p;t++){let e=u[t],i=e.vlambda,s=e.wlambda;i.set(0,0,0),s.set(0,0,0)}for(l=0;l!==a;l++){n=0;for(let t=0;t!==c;t++){let e=d[t];i=iW[t],s=iL[t],r=iN[t],o=s*(i-e.computeGWlambda()-e.eps*r),r+o<e.minForce?o=e.minForce-r:r+o>e.maxForce&&(o=e.maxForce-r),iN[t]+=o,n+=o>0?o:-o,e.addToWlambda(o)}if(n*n<h)break}for(let t=0;t!==p;t++){let e=u[t],i=e.velocity,s=e.angularVelocity;e.vlambda.vmul(e.linearFactor,e.vlambda),i.vadd(e.vlambda,i),e.wlambda.vmul(e.angularFactor,e.wlambda),s.vadd(e.wlambda,s)}let e=d.length,y=1/t;for(;e--;)d[e].multiplier=iN[e]*y}return l}}let iN=[],iL=[],iW=[];class iV extends iP{constructor(t){for(super(),this.iterations=10,this.tolerance=1e-7,this.subsolver=t,this.nodes=[],this.nodePool=[];this.nodePool.length<128;)this.nodePool.push(this.createNode())}createNode(){return{body:null,children:[],eqs:[],visited:!1}}solve(t,e){let i,s=this.nodePool,o=e.bodies,n=this.equations,r=n.length,l=o.length,a=this.subsolver;for(;s.length<l;)s.push(this.createNode());ij.length=l;for(let t=0;t<l;t++)ij[t]=s[t];for(let t=0;t!==l;t++){let e=ij[t];e.body=o[t],e.children.length=0,e.eqs.length=0,e.visited=!1}for(let t=0;t!==r;t++){let e=n[t],i=o.indexOf(e.bi),s=o.indexOf(e.bj),r=ij[i],l=ij[s];r.children.push(l),r.eqs.push(e),l.children.push(r),l.eqs.push(e)}let h=0,d=iO;for(a.tolerance=this.tolerance,a.iterations=this.iterations;i=iH(ij);){d.length=0,ik.bodies.length=0,function(t,e,i,s){for(iD.push(t),t.visited=!0,e(t,i,s);iD.length;){let t,o=iD.pop();for(;t=iH(o.children);)t.visited=!0,e(t,i,s),iD.push(t)}}(i,iU,ik.bodies,d);let e=d.length;d=d.sort(iG);for(let t=0;t!==e;t++)a.addEquation(d[t]);a.solve(t,ik),a.removeAllEquations(),h++}return h}}let ij=[],iO=[],ik={bodies:[]},i_=j.STATIC;function iH(t){let e=t.length;for(let i=0;i!==e;i++){let e=t[i];if(!e.visited&&!(e.body.type&i_))return e}return!1}let iD=[];function iU(t,e,i){e.push(t.body);let s=t.eqs.length;for(let e=0;e!==s;e++){let s=t.eqs[e];i.includes(s)||i.push(s)}}function iG(t,e){return e.id-t.id}class iY{constructor(){this.objects=[],this.type=Object}release(){let t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){let e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class iX extends iY{constructor(){super(...arguments),this.type=p}constructObject(){return new p}}let i$={sphereSphere:z.types.SPHERE,spherePlane:z.types.SPHERE|z.types.PLANE,boxBox:z.types.BOX|z.types.BOX,sphereBox:z.types.SPHERE|z.types.BOX,planeBox:z.types.PLANE|z.types.BOX,convexConvex:z.types.CONVEXPOLYHEDRON,sphereConvex:z.types.SPHERE|z.types.CONVEXPOLYHEDRON,planeConvex:z.types.PLANE|z.types.CONVEXPOLYHEDRON,boxConvex:z.types.BOX|z.types.CONVEXPOLYHEDRON,sphereHeightfield:z.types.SPHERE|z.types.HEIGHTFIELD,boxHeightfield:z.types.BOX|z.types.HEIGHTFIELD,convexHeightfield:z.types.CONVEXPOLYHEDRON|z.types.HEIGHTFIELD,sphereParticle:z.types.PARTICLE|z.types.SPHERE,planeParticle:z.types.PLANE|z.types.PARTICLE,boxParticle:z.types.BOX|z.types.PARTICLE,convexParticle:z.types.PARTICLE|z.types.CONVEXPOLYHEDRON,cylinderCylinder:z.types.CYLINDER,sphereCylinder:z.types.SPHERE|z.types.CYLINDER,planeCylinder:z.types.PLANE|z.types.CYLINDER,boxCylinder:z.types.BOX|z.types.CYLINDER,convexCylinder:z.types.CONVEXPOLYHEDRON|z.types.CYLINDER,heightfieldCylinder:z.types.HEIGHTFIELD|z.types.CYLINDER,particleCylinder:z.types.PARTICLE|z.types.CYLINDER,sphereTrimesh:z.types.SPHERE|z.types.TRIMESH,planeTrimesh:z.types.PLANE|z.types.TRIMESH};class iK{get[i$.sphereSphere](){return this.sphereSphere}get[i$.spherePlane](){return this.spherePlane}get[i$.boxBox](){return this.boxBox}get[i$.sphereBox](){return this.sphereBox}get[i$.planeBox](){return this.planeBox}get[i$.convexConvex](){return this.convexConvex}get[i$.sphereConvex](){return this.sphereConvex}get[i$.planeConvex](){return this.planeConvex}get[i$.boxConvex](){return this.boxConvex}get[i$.sphereHeightfield](){return this.sphereHeightfield}get[i$.boxHeightfield](){return this.boxHeightfield}get[i$.convexHeightfield](){return this.convexHeightfield}get[i$.sphereParticle](){return this.sphereParticle}get[i$.planeParticle](){return this.planeParticle}get[i$.boxParticle](){return this.boxParticle}get[i$.convexParticle](){return this.convexParticle}get[i$.cylinderCylinder](){return this.convexConvex}get[i$.sphereCylinder](){return this.sphereConvex}get[i$.planeCylinder](){return this.planeConvex}get[i$.boxCylinder](){return this.boxConvex}get[i$.convexCylinder](){return this.convexConvex}get[i$.heightfieldCylinder](){return this.heightfieldCylinder}get[i$.particleCylinder](){return this.particleCylinder}get[i$.sphereTrimesh](){return this.sphereTrimesh}get[i$.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new iX,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,i,s,o,n){let r;this.contactPointPool.length?((r=this.contactPointPool.pop()).bi=t,r.bj=e):r=new t$(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&i.collisionResponse&&s.collisionResponse;let l=this.currentContactMaterial;r.restitution=l.restitution,r.setSpookParams(l.contactEquationStiffness,l.contactEquationRelaxation,this.world.dt);let a=i.material||t.material,h=s.material||e.material;return a&&h&&a.restitution>=0&&h.restitution>=0&&(r.restitution=a.restitution*h.restitution),r.si=o||i,r.sj=n||s,r}createFrictionEquationsFromContact(t,e){let i=t.bi,s=t.bj,o=t.si,n=t.sj,r=this.world,l=this.currentContactMaterial,a=l.friction,h=o.material||i.material,d=n.material||s.material;if(h&&d&&h.friction>=0&&d.friction>=0&&(a=h.friction*d.friction),a>0){let o=a*(r.frictionGravity||r.gravity).length(),n=i.invMass+s.invMass;n>0&&(n=1/n);let h=this.frictionEquationPool,d=h.length?h.pop():new ea(i,s,o*n),c=h.length?h.pop():new ea(i,s,o*n);return d.bi=c.bi=i,d.bj=c.bj=s,d.minForce=c.minForce=-o*n,d.maxForce=c.maxForce=o*n,d.ri.copy(t.ri),d.rj.copy(t.rj),c.ri.copy(t.ri),c.rj.copy(t.rj),t.ni.tangents(d.t,c.t),d.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),c.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),d.enabled=c.enabled=t.enabled,e.push(d,c),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||1===t)return;let i=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];iZ.setZero(),iQ.setZero(),iJ.setZero();let o=e.bi;e.bj;for(let i=0;i!==t;i++)(e=this.result[this.result.length-1-i]).bi!==o?(iZ.vadd(e.ni,iZ),iQ.vadd(e.ri,iQ),iJ.vadd(e.rj,iJ)):(iZ.vsub(e.ni,iZ),iQ.vadd(e.rj,iQ),iJ.vadd(e.ri,iJ));let n=1/t;iQ.scale(n,i.ri),iJ.scale(n,i.rj),s.ri.copy(i.ri),s.rj.copy(i.rj),iZ.normalize(),iZ.tangents(i.t,s.t)}getContacts(t,e,i,s,o,n,r){this.contactPointPool=o,this.frictionEquationPool=r,this.result=s,this.frictionResult=n;for(let s=0,o=t.length;s!==o;s++){let o=t[s],n=e[s],r=null;o.material&&n.material&&(r=i.getContactMaterial(o.material,n.material)||null);let l=o.type&j.KINEMATIC&&n.type&j.STATIC||o.type&j.STATIC&&n.type&j.KINEMATIC||o.type&j.KINEMATIC&&n.type&j.KINEMATIC;for(let t=0;t<o.shapes.length;t++){o.quaternion.mult(o.shapeOrientations[t],i2),o.quaternion.vmult(o.shapeOffsets[t],i0),i0.vadd(o.position,i0);let e=o.shapes[t];for(let t=0;t<n.shapes.length;t++){n.quaternion.mult(n.shapeOrientations[t],i3),n.quaternion.vmult(n.shapeOffsets[t],i1),i1.vadd(n.position,i1);let s=n.shapes[t];if(!(e.collisionFilterMask&s.collisionFilterGroup&&s.collisionFilterMask&e.collisionFilterGroup)||i0.distanceTo(i1)>e.boundingSphereRadius+s.boundingSphereRadius)continue;let a=null;e.material&&s.material&&(a=i.getContactMaterial(e.material,s.material)||null),this.currentContactMaterial=a||r||i.defaultContactMaterial;let h=this[e.type|s.type];if(h){let t=!1;(e.type<s.type?h.call(this,e,s,i0,i1,i2,i3,o,n,e,s,l):h.call(this,s,e,i1,i0,i3,i2,n,o,e,s,l))&&l&&(i.shapeOverlapKeeper.set(e.id,s.id),i.bodyOverlapKeeper.set(o.id,n.id))}}}}}sphereSphere(t,e,i,s,o,n,r,l,a,h,d){if(d)return i.distanceSquared(s)<(t.radius+e.radius)**2;let c=this.createContactEquation(r,l,t,e,a,h);s.vsub(i,c.ni),c.ni.normalize(),c.ri.copy(c.ni),c.rj.copy(c.ni),c.ri.scale(t.radius,c.ri),c.rj.scale(-e.radius,c.rj),c.ri.vadd(i,c.ri),c.ri.vsub(r.position,c.ri),c.rj.vadd(s,c.rj),c.rj.vsub(l.position,c.rj),this.result.push(c),this.createFrictionEquationsFromContact(c,this.frictionResult)}spherePlane(t,e,i,s,o,n,r,l,a,h,d){let c=this.createContactEquation(r,l,t,e,a,h);if(c.ni.set(0,0,1),n.vmult(c.ni,c.ni),c.ni.negate(c.ni),c.ni.normalize(),c.ni.scale(t.radius,c.ri),i.vsub(s,su),c.ni.scale(c.ni.dot(su),sp),su.vsub(sp,c.rj),-su.dot(c.ni)<=t.radius){if(d)return!0;let t=c.ri,e=c.rj;t.vadd(i,t),t.vsub(r.position,t),e.vadd(s,e),e.vsub(l.position,e),this.result.push(c),this.createFrictionEquationsFromContact(c,this.frictionResult)}}boxBox(t,e,i,s,o,n,r,l,a,h,d){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,i,s,o,n,r,l,t,e,d)}sphereBox(t,e,i,s,o,n,r,l,a,h,d){let c=this.v3pool;i.vsub(s,sg),e.getSideNormals(sb,n);let u=t.radius,p=!1,y=null,v=0,m=0,g=0,w=null;for(let t=0,e=sb.length;t!==e&&!1===p;t++){sw.copy(sb[t]);let e=sw.length();sw.normalize();let i=sg.dot(sw);if(i<e+u&&i>0){sx.copy(sb[(t+1)%3]),sf.copy(sb[(t+2)%3]);let s=sx.length(),o=sf.length();sx.normalize(),sf.normalize();let n=sg.dot(sx),r=sg.dot(sf);if(n<s&&n>-s&&r<o&&r>-o){let t=Math.abs(i-e-u);if((null===w||t<w)&&(w=t,m=n,g=r,y=e,sB.copy(sw),sE.copy(sx),sS.copy(sf),v++,d))return!0}}}if(v){p=!0;let o=this.createContactEquation(r,l,t,e,a,h);sB.scale(-u,o.ri),o.ni.copy(sB),o.ni.negate(o.ni),sB.scale(y,sB),sE.scale(m,sE),sB.vadd(sE,sB),sS.scale(g,sS),sB.vadd(sS,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}let x=c.get();for(let o=0;2!==o&&!p;o++)for(let n=0;2!==n&&!p;n++)for(let c=0;2!==c&&!p;c++)if(x.set(0,0,0),o?x.vadd(sb[0],x):x.vsub(sb[0],x),n?x.vadd(sb[1],x):x.vsub(sb[1],x),c?x.vadd(sb[2],x):x.vsub(sb[2],x),s.vadd(x,sA),sA.vsub(i,sA),sA.lengthSquared()<u*u){if(d)return!0;p=!0;let o=this.createContactEquation(r,l,t,e,a,h);o.ri.copy(sA),o.ri.normalize(),o.ni.copy(o.ri),o.ri.scale(u,o.ri),o.rj.copy(x),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}c.release(x),x=null;let f=c.get(),b=c.get(),A=c.get(),B=c.get(),E=c.get(),S=sb.length;for(let o=0;o!==S&&!p;o++)for(let n=0;n!==S&&!p;n++)if(o%3!=n%3){sb[n].cross(sb[o],f),f.normalize(),sb[o].vadd(sb[n],b),A.copy(i),A.vsub(b,A),A.vsub(s,A);let c=A.dot(f);f.scale(c,B);let y=0;for(;y===o%3||y===n%3;)y++;E.copy(i),E.vsub(B,E),E.vsub(b,E),E.vsub(s,E);let v=Math.abs(c),m=E.length();if(v<sb[y].length()&&m<u){if(d)return!0;p=!0;let o=this.createContactEquation(r,l,t,e,a,h);b.vadd(B,o.rj),o.rj.copy(o.rj),E.negate(o.ni),o.ni.normalize(),o.ri.copy(o.rj),o.ri.vadd(s,o.ri),o.ri.vsub(i,o.ri),o.ri.normalize(),o.ri.scale(u,o.ri),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}c.release(f,b,A,B,E)}planeBox(t,e,i,s,o,n,r,l,a,h,d){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,i,s,o,n,r,l,t,e,d)}convexConvex(t,e,i,s,o,n,r,l,a,h,d,c,u){if(!(i.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,i,o,s,n,sO,c,u)){let c=[];t.clipAgainstHull(i,o,e,s,n,sO,-100,100,c);let u=0;for(let o=0;o!==c.length;o++){if(d)return!0;let n=this.createContactEquation(r,l,t,e,a,h),p=n.ri,y=n.rj;sO.negate(n.ni),c[o].normal.negate(sk),sk.scale(c[o].depth,sk),c[o].point.vadd(sk,p),y.copy(c[o].point),p.vsub(i,p),y.vsub(s,y),p.vadd(i,p),p.vsub(r.position,p),y.vadd(s,y),y.vsub(l.position,y),this.result.push(n),u++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(n,this.frictionResult)}this.enableFrictionReduction&&u&&this.createFrictionFromAverage(u)}}sphereConvex(t,e,i,s,o,n,r,l,a,h,d){let c=this.v3pool;i.vsub(s,sz);let u=e.faceNormals,p=e.faces,y=e.vertices,v=t.radius,m=!1;for(let o=0;o!==y.length;o++){let c=y[o];if(n.vmult(c,sR),s.vadd(sR,sR),sR.vsub(i,sM),sM.lengthSquared()<v*v){if(d)return!0;m=!0;let o=this.createContactEquation(r,l,t,e,a,h);o.ri.copy(sM),o.ri.normalize(),o.ni.copy(o.ri),o.ri.scale(v,o.ri),sR.vsub(s,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult);return}}for(let o=0,g=p.length;o!==g&&!1===m;o++){let g=u[o],w=p[o];n.vmult(g,sT),n.vmult(y[w[0]],sI),sI.vadd(s,sI),sT.scale(-v,sP),i.vadd(sP,sP),sP.vsub(sI,sq);let x=sq.dot(sT);if(i.vsub(sI,sN),x<0&&sN.dot(sT)>0){let o=[];for(let t=0,e=w.length;t!==e;t++){let e=c.get();n.vmult(y[w[t]],e),s.vadd(e,e),o.push(e)}if(function(t,e,i){let s=null,o=t.length;for(let n=0;n!==o;n++){let r=t[n];t[(n+1)%o].vsub(r,sy),sy.cross(e,sv),i.vsub(r,sm);let l=sv.dot(sm);if(null!==s&&(!(l>0)||!0!==s)&&(!(l<=0)||!1!==s))return!1;null===s&&(s=l>0)}return!0}(o,sT,i)){if(d)return!0;m=!0;let n=this.createContactEquation(r,l,t,e,a,h);sT.scale(-v,n.ri),sT.negate(n.ni);let u=c.get();sT.scale(-x,u);let p=c.get();sT.scale(-v,p),i.vsub(s,n.rj),n.rj.vadd(p,n.rj),n.rj.vadd(u,n.rj),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),c.release(u),c.release(p),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);for(let t=0,e=o.length;t!==e;t++)c.release(o[t]);return}for(let u=0;u!==w.length;u++){let p=c.get(),m=c.get();n.vmult(y[w[(u+1)%w.length]],p),n.vmult(y[w[(u+2)%w.length]],m),s.vadd(p,p),s.vadd(m,m),m.vsub(p,sC),sC.unit(sF);let g=c.get(),x=c.get();i.vsub(p,x);let f=x.dot(sF);sF.scale(f,g),g.vadd(p,g);let b=c.get();if(g.vsub(i,b),f>0&&f*f<sC.lengthSquared()&&b.lengthSquared()<v*v){if(d)return!0;let n=this.createContactEquation(r,l,t,e,a,h);g.vsub(s,n.rj),g.vsub(i,n.ni),n.ni.normalize(),n.ni.scale(v,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);for(let t=0,e=o.length;t!==e;t++)c.release(o[t]);c.release(p),c.release(m),c.release(g),c.release(b),c.release(x);return}c.release(p),c.release(m),c.release(g),c.release(b),c.release(x)}for(let t=0,e=o.length;t!==e;t++)c.release(o[t])}}}planeConvex(t,e,i,s,o,n,r,l,a,h,d){sW.set(0,0,1),o.vmult(sW,sW);let c=0;for(let o=0;o!==e.vertices.length;o++)if(sL.copy(e.vertices[o]),n.vmult(sL,sL),s.vadd(sL,sL),sL.vsub(i,sV),0>=sW.dot(sV)){if(d)return!0;let o=this.createContactEquation(r,l,t,e,a,h);sW.scale(sW.dot(sV),sj),sL.vsub(sj,sj),sj.vsub(i,o.ri),o.ni.copy(sW),sL.vsub(s,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),c++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(o,this.frictionResult)}this.enableFrictionReduction&&c&&this.createFrictionFromAverage(c)}boxConvex(t,e,i,s,o,n,r,l,a,h,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,i,s,o,n,r,l,t,e,d)}sphereHeightfield(t,e,i,s,o,n,r,l,a,h,d){let c=e.data,u=t.radius,p=e.elementSize;C.pointToLocalFrame(s,n,i,s0);let y=Math.floor((s0.x-u)/p)-1,v=Math.ceil((s0.x+u)/p)+1,m=Math.floor((s0.y-u)/p)-1,g=Math.ceil((s0.y+u)/p)+1;if(v<0||g<0||y>c.length||m>c[0].length)return;y<0&&(y=0),v<0&&(v=0),m<0&&(m=0),g<0&&(g=0),y>=c.length&&(y=c.length-1),v>=c.length&&(v=c.length-1),g>=c[0].length&&(g=c[0].length-1),m>=c[0].length&&(m=c[0].length-1);let w=[];e.getRectMinMax(y,m,v,g,w);let x=w[0],f=w[1];if(s0.z-u>f||s0.z+u<x)return;let b=this.result;for(let a=y;a<v;a++)for(let h=m;h<g;h++){let c=b.length,u=!1;if(e.getConvexTrianglePillar(a,h,!1),C.pointToWorldFrame(s,n,e.pillarOffset,s1),i.distanceTo(s1)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(u=this.sphereConvex(t,e.pillarConvex,i,s1,o,n,r,l,t,e,d)),d&&u||(e.getConvexTrianglePillar(a,h,!0),C.pointToWorldFrame(s,n,e.pillarOffset,s1),i.distanceTo(s1)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(u=this.sphereConvex(t,e.pillarConvex,i,s1,o,n,r,l,t,e,d)),d&&u))return!0;if(b.length-c>2)return}}boxHeightfield(t,e,i,s,o,n,r,l,a,h,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,i,s,o,n,r,l,t,e,d)}convexHeightfield(t,e,i,s,o,n,r,l,a,h,d){let c=e.data,u=e.elementSize,p=t.boundingSphereRadius;C.pointToLocalFrame(s,n,i,sZ);let y=Math.floor((sZ.x-p)/u)-1,v=Math.ceil((sZ.x+p)/u)+1,m=Math.floor((sZ.y-p)/u)-1,g=Math.ceil((sZ.y+p)/u)+1;if(v<0||g<0||y>c.length||m>c[0].length)return;y<0&&(y=0),v<0&&(v=0),m<0&&(m=0),g<0&&(g=0),y>=c.length&&(y=c.length-1),v>=c.length&&(v=c.length-1),g>=c[0].length&&(g=c[0].length-1),m>=c[0].length&&(m=c[0].length-1);let w=[];e.getRectMinMax(y,m,v,g,w);let x=w[0],f=w[1];if(!(sZ.z-p>f)&&!(sZ.z+p<x))for(let a=y;a<v;a++)for(let h=m;h<g;h++){let c=!1;if(e.getConvexTrianglePillar(a,h,!1),C.pointToWorldFrame(s,n,e.pillarOffset,sQ),i.distanceTo(sQ)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(c=this.convexConvex(t,e.pillarConvex,i,sQ,o,n,r,l,null,null,d,sJ,null)),d&&c||(e.getConvexTrianglePillar(a,h,!0),C.pointToWorldFrame(s,n,e.pillarOffset,sQ),i.distanceTo(sQ)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(c=this.convexConvex(t,e.pillarConvex,i,sQ,o,n,r,l,null,null,d,sJ,null)),d&&c))return!0}}sphereParticle(t,e,i,s,o,n,r,l,a,h,d){if(sU.set(0,0,1),s.vsub(i,sU),sU.lengthSquared()<=t.radius*t.radius){if(d)return!0;let i=this.createContactEquation(l,r,e,t,a,h);sU.normalize(),i.rj.copy(sU),i.rj.scale(t.radius,i.rj),i.ni.copy(sU),i.ni.negate(i.ni),i.ri.set(0,0,0),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}planeParticle(t,e,i,s,o,n,r,l,a,h,d){if(s_.set(0,0,1),r.quaternion.vmult(s_,s_),s.vsub(r.position,sH),0>=s_.dot(sH)){if(d)return!0;let i=this.createContactEquation(l,r,e,t,a,h);i.ni.copy(s_),i.ni.negate(i.ni),i.ri.set(0,0,0),s_.scale(s_.dot(s),sD),s.vsub(sD,sD),i.rj.copy(sD),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}boxParticle(t,e,i,s,o,n,r,l,a,h,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,i,s,o,n,r,l,t,e,d)}convexParticle(t,e,i,s,o,n,r,l,a,h,d){let c=-1,u=null;if(sY.copy(s),sY.vsub(i,sY),o.conjugate(sG),sG.vmult(sY,sY),t.pointIsInside(sY)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(i,o),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(o);for(let e=0,i=t.faces.length;e!==i;e++){let i=[t.worldVertices[t.faces[e][0]]],o=t.worldFaceNormals[e];s.vsub(i[0],s$);let n=-o.dot(s$);if(null===u||Math.abs(n)<Math.abs(u)){if(d)return!0;u=n,c=e,sX.copy(o)}}if(-1!==c){let o=this.createContactEquation(l,r,e,t,a,h);sX.scale(u,sK),sK.vadd(s,sK),sK.vsub(i,sK),o.rj.copy(sK),sX.negate(o.ni),o.ri.set(0,0,0);let n=o.ri,d=o.rj;n.vadd(s,n),n.vsub(l.position,n),d.vadd(i,d),d.vsub(r.position,d),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,i,s,o,n,r,l,a,h,d){return this.convexHeightfield(e,t,s,i,n,o,l,r,a,h,d)}particleCylinder(t,e,i,s,o,n,r,l,a,h,d){return this.convexParticle(e,t,s,i,n,o,l,r,a,h,d)}sphereTrimesh(t,e,i,s,o,n,r,l,a,h,d){C.pointToLocalFrame(s,n,i,sn);let c=t.radius;sd.lowerBound.set(sn.x-c,sn.y-c,sn.z-c),sd.upperBound.set(sn.x+c,sn.y+c,sn.z+c),e.getTrianglesInAABB(sd,sc);let u=t.radius*t.radius;for(let o=0;o<sc.length;o++)for(let c=0;c<3;c++)if(e.getVertex(e.indices[3*sc[o]+c],i9),i9.vsub(sn,i8),i8.lengthSquared()<=u){if(st.copy(i9),C.pointToWorldFrame(s,n,st,i9),i9.vsub(i,i8),d)return!0;let o=this.createContactEquation(r,l,t,e,a,h);o.ni.copy(i8),o.ni.normalize(),o.ri.copy(o.ni),o.ri.scale(t.radius,o.ri),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.copy(i9),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}for(let o=0;o<sc.length;o++)for(let c=0;c<3;c++){e.getVertex(e.indices[3*sc[o]+c],se),e.getVertex(e.indices[3*sc[o]+(c+1)%3],si),si.vsub(se,ss),sn.vsub(si,sr);let u=sr.dot(ss);sn.vsub(se,sr);let p=sr.dot(ss);if(p>0&&u<0&&(sn.vsub(se,sr),so.copy(ss),so.normalize(),p=sr.dot(so),so.scale(p,sr),sr.vadd(se,sr),sr.distanceTo(sn)<t.radius)){if(d)return!0;let o=this.createContactEquation(r,l,t,e,a,h);sr.vsub(sn,o.ni),o.ni.normalize(),o.ni.scale(t.radius,o.ri),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),C.pointToWorldFrame(s,n,sr,sr),sr.vsub(l.position,o.rj),C.vectorToWorldFrame(n,o.ni,o.ni),C.vectorToWorldFrame(n,o.ri,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}for(let o=0,c=sc.length;o!==c;o++){e.getTriangleVertices(sc[o],sl,sa,sh),e.getNormal(sc[o],i7),sn.vsub(sl,sr);let c=sr.dot(i7);if(i7.scale(c,sr),sn.vsub(sr,sr),c=sr.distanceTo(sn),th.pointInTriangle(sr,sl,sa,sh)&&c<t.radius){if(d)return!0;let o=this.createContactEquation(r,l,t,e,a,h);sr.vsub(sn,o.ni),o.ni.normalize(),o.ni.scale(t.radius,o.ri),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),C.pointToWorldFrame(s,n,sr,sr),sr.vsub(l.position,o.rj),C.vectorToWorldFrame(n,o.ni,o.ni),C.vectorToWorldFrame(n,o.ri,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}sc.length=0}planeTrimesh(t,e,i,s,o,n,r,l,a,h,d){let c=new p;i5.set(0,0,1),o.vmult(i5,i5);for(let o=0;o<e.vertices.length/3;o++){e.getVertex(o,c);let u=new p;if(u.copy(c),C.pointToWorldFrame(s,n,u,c),c.vsub(i,i6),0>=i5.dot(i6)){if(d)return!0;let i=this.createContactEquation(r,l,t,e,a,h);i.ni.copy(i5),i5.scale(i6.dot(i5),i4),c.vsub(i4,i4),i.ri.copy(i4),i.ri.vsub(r.position,i.ri),i.rj.copy(c),i.rj.vsub(l.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}}}let iZ=new p,iQ=new p,iJ=new p,i0=new p,i1=new p,i2=new A,i3=new A,i5=new p,i6=new p,i4=new p,i7=new p,i8=new p;new p;let i9=new p,st=new p,se=new p,si=new p,ss=new p,so=new p,sn=new p,sr=new p,sl=new p,sa=new p,sh=new p,sd=new g,sc=[],su=new p,sp=new p,sy=new p,sv=new p,sm=new p,sg=new p,sw=new p,sx=new p,sf=new p,sb=[new p,new p,new p,new p,new p,new p],sA=new p,sB=new p,sE=new p,sS=new p,sz=new p,sC=new p,sF=new p,sM=new p,sR=new p,sT=new p,sI=new p,sP=new p,sq=new p,sN=new p;new p,new p;let sL=new p,sW=new p,sV=new p,sj=new p,sO=new p,sk=new p,s_=new p,sH=new p,sD=new p,sU=new p,sG=new A,sY=new p;new p;let sX=new p,s$=new p,sK=new p,sZ=new p,sQ=new p,sJ=[0],s0=new p,s1=new p;class s2{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){let i=e;e=t,t=i}return t<<16|e}set(t,e){let i=this.getKey(t,e),s=this.current,o=0;for(;i>s[o];)o++;if(i!==s[o]){for(let t=s.length-1;t>=o;t--)s[t+1]=s[t];s[o]=i}}tick(){let t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){let i=this.current,s=this.previous,o=i.length,n=s.length,r=0;for(let e=0;e<o;e++){let o=!1,n=i[e];for(;n>s[r];)r++;n===s[r]||s3(t,n)}r=0;for(let t=0;t<n;t++){let o=!1,n=s[t];for(;n>i[r];)r++;i[r]===n||s3(e,n)}}}function s3(t,e){t.push((0xffff0000&e)>>16,65535&e)}let s5=(t,e)=>t<e?`${t}-${e}`:`${e}-${t}`;class s6{constructor(){this.data={keys:[]}}get(t,e){let i=s5(t,e);return this.data[i]}set(t,e,i){let s=s5(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=i}delete(t,e){let i=s5(t,e),s=this.data.keys.indexOf(i);-1!==s&&this.data.keys.splice(s,1),delete this.data[i]}reset(){let t=this.data,e=t.keys;for(;e.length>0;){let i=e.pop();delete t[i]}}}class s4 extends b{constructor(t){void 0===t&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==t.quatNormalizeSkip?t.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==t.quatNormalizeFast&&t.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new p,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new p,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=void 0!==t.broadphase?t.broadphase:new tr,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==t.solver?t.solver:new iq,this.constraints=[],this.narrowphase=new iK(this),this.collisionMatrix=new f,this.collisionMatrixPrevious=new f,this.bodyOverlapKeeper=new s2,this.shapeOverlapKeeper=new s2,this.contactmaterials=[],this.contactMaterialTable=new s6,this.defaultMaterial=new eu("default"),this.defaultContactMaterial=new ec(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){let t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){let e=this.constraints.indexOf(t);-1!==e&&this.constraints.splice(e,1)}rayTest(t,e,i){i instanceof tl?this.raycastClosest(t,e,{skipBackfaces:!0},i):this.raycastAll(t,e,{skipBackfaces:!0},i)}raycastAll(t,e,i,s){return void 0===i&&(i={}),i.mode=th.ALL,i.from=t,i.to=e,i.callback=s,s7.intersectWorld(this,i)}raycastAny(t,e,i,s){return void 0===i&&(i={}),i.mode=th.ANY,i.from=t,i.to=e,i.result=s,s7.intersectWorld(this,i)}raycastClosest(t,e,i,s){return void 0===i&&(i={}),i.mode=th.CLOSEST,i.from=t,i.to=e,i.result=s,s7.intersectWorld(this,i)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof j&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;let e=this.bodies.length-1,i=this.bodies,s=i.indexOf(t);if(-1!==s){i.splice(s,1);for(let t=0;t!==i.length;t++)i[t].index=t;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){let e=this.bodies;for(let i=0;i<e.length;i++){let s=e[i].shapes;for(let e=0;e<s.length;e++){let i=s[e];if(i.id===t)return i}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){let e=this.contactmaterials.indexOf(t);-1!==e&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){void 0===t&&(t=1/60),void 0===e&&(e=10);let i=s8.now()/1e3;if(this.lastCallTime){let s=i-this.lastCallTime;this.step(t,s,e)}else this.step(t,void 0,e);this.lastCallTime=i}step(t,e,i){if(void 0===i&&(i=10),void 0===e)this.internalStep(t),this.time+=t;else{this.accumulator+=e;let s=s8.now(),o=0;for(;this.accumulator>=t&&o<i&&(this.internalStep(t),this.accumulator-=t,o++,!(s8.now()-s>1e3*t)););this.accumulator=this.accumulator%t;let n=this.accumulator/t;for(let t=0;t!==this.bodies.length;t++){let e=this.bodies[t];e.previousPosition.lerp(e.position,n,e.interpolatedPosition),e.previousQuaternion.slerp(e.quaternion,n,e.interpolatedQuaternion),e.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;let e=this.contacts,i=this.bodies.length,s=this.bodies,o=this.solver,n=this.gravity,r=this.doProfiling,l=this.profile,a=j.DYNAMIC,h=-1/0,d=this.constraints;n.length();let c=n.x,u=n.y,p=n.z,y=0;for(r&&(h=s8.now()),y=0;y!==i;y++){let t=s[y];if(t.type===a){let e=t.force,i=t.mass;e.x+=i*c,e.y+=i*u,e.z+=i*p}}for(let t=0,e=this.subsystems.length;t!==e;t++)this.subsystems[t].update();r&&(h=s8.now()),oo.length=0,on.length=0,this.broadphase.collisionPairs(this,oo,on),r&&(l.broadphase=s8.now()-h);let v=d.length;for(y=0;y!==v;y++){let t=d[y];if(!t.collideConnected)for(let e=oo.length-1;e>=0;e-=1)(t.bodyA===oo[e]&&t.bodyB===on[e]||t.bodyB===oo[e]&&t.bodyA===on[e])&&(oo.splice(e,1),on.splice(e,1))}this.collisionMatrixTick(),r&&(h=s8.now());let m=e.length;for(y=0;y!==m;y++)oi.push(e[y]);e.length=0;let g=this.frictionEquations.length;for(y=0;y!==g;y++)os.push(this.frictionEquations[y]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(oo,on,this,e,oi,this.frictionEquations,os),r&&(l.narrowphase=s8.now()-h),r&&(h=s8.now()),y=0;y<this.frictionEquations.length;y++)o.addEquation(this.frictionEquations[y]);let w=e.length;for(let t=0;t!==w;t++){let i,s=e[t],n=s.bi,r=s.bj,l=s.si,a=s.sj;(n.material&&r.material&&this.getContactMaterial(n.material,r.material)||this.defaultContactMaterial).friction,n.material&&r.material&&(n.material.friction>=0&&r.material.friction>=0&&(n.material.friction,r.material.friction),n.material.restitution>=0&&r.material.restitution>=0&&(s.restitution=n.material.restitution*r.material.restitution)),o.addEquation(s),n.allowSleep&&n.type===j.DYNAMIC&&n.sleepState===j.SLEEPING&&r.sleepState===j.AWAKE&&r.type!==j.STATIC&&r.velocity.lengthSquared()+r.angularVelocity.lengthSquared()>=2*r.sleepSpeedLimit**2&&(n.wakeUpAfterNarrowphase=!0),r.allowSleep&&r.type===j.DYNAMIC&&r.sleepState===j.SLEEPING&&n.sleepState===j.AWAKE&&n.type!==j.STATIC&&n.velocity.lengthSquared()+n.angularVelocity.lengthSquared()>=2*n.sleepSpeedLimit**2&&(r.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(n,r,!0),this.collisionMatrixPrevious.get(n,r)||(oe.body=r,oe.contact=s,n.dispatchEvent(oe),oe.body=n,r.dispatchEvent(oe)),this.bodyOverlapKeeper.set(n.id,r.id),this.shapeOverlapKeeper.set(l.id,a.id)}for(this.emitContactEvents(),r&&(l.makeContactConstraints=s8.now()-h,h=s8.now()),y=0;y!==i;y++){let t=s[y];t.wakeUpAfterNarrowphase&&(t.wakeUp(),t.wakeUpAfterNarrowphase=!1)}for(y=0,v=d.length;y!==v;y++){let t=d[y];t.update();for(let e=0,i=t.equations.length;e!==i;e++){let i=t.equations[e];o.addEquation(i)}}o.solve(t,this),r&&(l.solve=s8.now()-h),o.removeAllEquations();let x=Math.pow;for(y=0;y!==i;y++){let e=s[y];if(e.type&a){let i=x(1-e.linearDamping,t),s=e.velocity;s.scale(i,s);let o=e.angularVelocity;if(o){let i=x(1-e.angularDamping,t);o.scale(i,o)}}}this.dispatchEvent(ot),r&&(h=s8.now());let f=this.stepnumber%(this.quatNormalizeSkip+1)==0,b=this.quatNormalizeFast;for(y=0;y!==i;y++)s[y].integrate(t,f,b);this.clearForces(),this.broadphase.dirty=!0,r&&(l.integrate=s8.now()-h),this.stepnumber+=1,this.dispatchEvent(s9);let A=!0;if(this.allowSleep)for(y=0,A=!1;y!==i;y++){let t=s[y];t.sleepTick(this.time),t.sleepState!==j.SLEEPING&&(A=!0)}this.hasActiveBodies=A}emitContactEvents(){let t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(or,ol),t){for(let t=0,e=or.length;t<e;t+=2)oa.bodyA=this.getBodyById(or[t]),oa.bodyB=this.getBodyById(or[t+1]),this.dispatchEvent(oa);oa.bodyA=oa.bodyB=null}if(e){for(let t=0,e=ol.length;t<e;t+=2)oh.bodyA=this.getBodyById(ol[t]),oh.bodyB=this.getBodyById(ol[t+1]),this.dispatchEvent(oh);oh.bodyA=oh.bodyB=null}or.length=ol.length=0;let i=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((i||s)&&this.shapeOverlapKeeper.getDiff(or,ol),i){for(let t=0,e=or.length;t<e;t+=2){let e=this.getShapeById(or[t]),i=this.getShapeById(or[t+1]);od.shapeA=e,od.shapeB=i,e&&(od.bodyA=e.body),i&&(od.bodyB=i.body),this.dispatchEvent(od)}od.bodyA=od.bodyB=od.shapeA=od.shapeB=null}if(s){for(let t=0,e=ol.length;t<e;t+=2){let e=this.getShapeById(ol[t]),i=this.getShapeById(ol[t+1]);oc.shapeA=e,oc.shapeB=i,e&&(oc.bodyA=e.body),i&&(oc.bodyB=i.body),this.dispatchEvent(oc)}oc.bodyA=oc.bodyB=oc.shapeA=oc.shapeB=null}}clearForces(){let t=this.bodies,e=t.length;for(let i=0;i!==e;i++){let e=t[i];e.force,e.torque,e.force.set(0,0,0),e.torque.set(0,0,0)}}}new g;let s7=new th,s8=globalThis.performance||{};if(!s8.now){let t=Date.now();s8.timing&&s8.timing.navigationStart&&(t=s8.timing.navigationStart),s8.now=()=>Date.now()-t}new p;let s9={type:"postStep"},ot={type:"preStep"},oe={type:j.COLLIDE_EVENT_NAME,body:null,contact:null},oi=[],os=[],oo=[],on=[],or=[],ol=[],oa={type:"beginContact",bodyA:null,bodyB:null},oh={type:"endContact",bodyA:null,bodyB:null},od={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},oc={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null}}};