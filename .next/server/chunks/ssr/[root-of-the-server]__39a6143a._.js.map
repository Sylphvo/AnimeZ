{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/phuvm/source/repos/AnimeZ/src/lib/session-security.ts"],"sourcesContent":["\"use client\";\r\n\r\nimport { SessionData, SessionConfig } from \"./types\";\r\n\r\n// Session configuration\r\nexport const SESSION_CONFIG: SessionConfig = {\r\n  defaultExpiration: 24 * 60 * 60 * 1000, // 24 hours\r\n  rememberMeExpiration: 30 * 24 * 60 * 60 * 1000, // 30 days\r\n  inactivityTimeout: 2 * 60 * 60 * 1000, // 2 hours\r\n  warningBeforeExpiry: 5 * 60 * 1000, // 5 minutes\r\n};\r\n\r\n// Storage keys\r\nexport const STORAGE_KEYS = {\r\n  SESSION: 'tailadmin_session',\r\n  LAST_ACTIVITY: 'tailadmin_last_activity',\r\n  SESSION_FINGERPRINT: 'tailadmin_fingerprint',\r\n} as const;\r\n\r\n// Generate a simple browser fingerprint for session security\r\nexport function generateFingerprint(): string {\r\n  if (typeof window === 'undefined') return '';\r\n  \r\n  const canvas = document.createElement('canvas');\r\n  const ctx = canvas.getContext('2d');\r\n  if (ctx) {\r\n    ctx.textBaseline = 'top';\r\n    ctx.font = '14px Arial';\r\n    ctx.fillText('Session fingerprint', 2, 2);\r\n  }\r\n  \r\n  const fingerprint = [\r\n    navigator.userAgent,\r\n    navigator.language,\r\n    screen.width + 'x' + screen.height,\r\n    new Date().getTimezoneOffset(),\r\n    canvas.toDataURL(),\r\n  ].join('|');\r\n  \r\n  return btoa(fingerprint).slice(0, 32);\r\n}\r\n\r\n// Simple encryption/decryption for session data\r\nexport function encryptSessionData(data: SessionData): string {\r\n  try {\r\n    const jsonString = JSON.stringify(data);\r\n    return btoa(jsonString);\r\n  } catch (error) {\r\n    console.error('Error encrypting session data:', error);\r\n    return '';\r\n  }\r\n}\r\n\r\nexport function decryptSessionData(encryptedData: string): SessionData | null {\r\n  try {\r\n    const jsonString = atob(encryptedData);\r\n    return JSON.parse(jsonString);\r\n  } catch (error) {\r\n    console.error('Error decrypting session data:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Generate a secure session token\r\nexport function generateSessionToken(): string {\r\n  const timestamp = Date.now().toString();\r\n  const randomBytes = Array.from(crypto.getRandomValues(new Uint8Array(16)))\r\n    .map(b => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n  \r\n  return btoa(`${timestamp}-${randomBytes}`).replace(/[+/=]/g, '');\r\n}\r\n\r\n// Validate session fingerprint\r\nexport function validateFingerprint(sessionFingerprint: string): boolean {\r\n  const currentFingerprint = generateFingerprint();\r\n  return sessionFingerprint === currentFingerprint;\r\n}\r\n\r\n// Check if session is expired\r\nexport function isSessionExpired(session: SessionData): boolean {\r\n  return Date.now() > session.expiresAt;\r\n}\r\n\r\n// Check if session is about to expire\r\nexport function isSessionNearExpiry(session: SessionData): boolean {\r\n  const timeUntilExpiry = session.expiresAt - Date.now();\r\n  return timeUntilExpiry <= SESSION_CONFIG.warningBeforeExpiry && timeUntilExpiry > 0;\r\n}\r\n\r\n// Update last activity timestamp\r\nexport function updateLastActivity(): void {\r\n  if (typeof window !== 'undefined') {\r\n    localStorage.setItem(STORAGE_KEYS.LAST_ACTIVITY, Date.now().toString());\r\n  }\r\n}\r\n\r\n// Check if user has been inactive too long\r\nexport function isInactive(): boolean {\r\n  if (typeof window === 'undefined') return false;\r\n  \r\n  const lastActivity = localStorage.getItem(STORAGE_KEYS.LAST_ACTIVITY);\r\n  if (!lastActivity) return true;\r\n  \r\n  const timeSinceActivity = Date.now() - parseInt(lastActivity);\r\n  return timeSinceActivity > SESSION_CONFIG.inactivityTimeout;\r\n}\r\n\r\n// Clean up expired sessions\r\nexport function cleanupExpiredSessions(): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  const sessionData = localStorage.getItem(STORAGE_KEYS.SESSION);\r\n  if (sessionData) {\r\n    const session = decryptSessionData(sessionData);\r\n    if (session && isSessionExpired(session)) {\r\n      localStorage.removeItem(STORAGE_KEYS.SESSION);\r\n      localStorage.removeItem(STORAGE_KEYS.LAST_ACTIVITY);\r\n      localStorage.removeItem(STORAGE_KEYS.SESSION_FINGERPRINT);\r\n    }\r\n  }\r\n}\r\n\r\n// Session event listeners for activity tracking\r\nexport function setupActivityTracking(): (() => void) | void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];\r\n  \r\n  const updateActivity = () => {\r\n    updateLastActivity();\r\n  };\r\n  \r\n  events.forEach(event => {\r\n    document.addEventListener(event, updateActivity, { passive: true });\r\n  });\r\n  \r\n  // Cleanup function\r\n  return () => {\r\n    events.forEach(event => {\r\n      document.removeEventListener(event, updateActivity);\r\n    });\r\n  };\r\n}\r\n\r\n// Handle page visibility change\r\nexport function setupVisibilityTracking(): void {\r\n  if (typeof window === 'undefined') return;\r\n  \r\n  document.addEventListener('visibilitychange', () => {\r\n    if (!document.hidden) {\r\n      updateLastActivity();\r\n      cleanupExpiredSessions();\r\n    }\r\n  });\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AAKO,MAAM,iBAAgC;IAC3C,mBAAmB,KAAK,KAAK,KAAK;IAClC,sBAAsB,KAAK,KAAK,KAAK,KAAK;IAC1C,mBAAmB,IAAI,KAAK,KAAK;IACjC,qBAAqB,IAAI,KAAK;AAChC;AAGO,MAAM,eAAe;IAC1B,SAAS;IACT,eAAe;IACf,qBAAqB;AACvB;AAGO,SAAS;IACd,wCAAmC,OAAO;;IAE1C,MAAM;IACN,MAAM;IAON,MAAM;AASR;AAGO,SAAS,mBAAmB,IAAiB;IAClD,IAAI;QACF,MAAM,aAAa,KAAK,SAAS,CAAC;QAClC,OAAO,KAAK;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO;IACT;AACF;AAEO,SAAS,mBAAmB,aAAqB;IACtD,IAAI;QACF,MAAM,aAAa,KAAK;QACxB,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO;IACT;AACF;AAGO,SAAS;IACd,MAAM,YAAY,KAAK,GAAG,GAAG,QAAQ;IACrC,MAAM,cAAc,MAAM,IAAI,CAAC,OAAO,eAAe,CAAC,IAAI,WAAW,MAClE,GAAG,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG,MACpC,IAAI,CAAC;IAER,OAAO,KAAK,GAAG,UAAU,CAAC,EAAE,aAAa,EAAE,OAAO,CAAC,UAAU;AAC/D;AAGO,SAAS,oBAAoB,kBAA0B;IAC5D,MAAM,qBAAqB;IAC3B,OAAO,uBAAuB;AAChC;AAGO,SAAS,iBAAiB,OAAoB;IACnD,OAAO,KAAK,GAAG,KAAK,QAAQ,SAAS;AACvC;AAGO,SAAS,oBAAoB,OAAoB;IACtD,MAAM,kBAAkB,QAAQ,SAAS,GAAG,KAAK,GAAG;IACpD,OAAO,mBAAmB,eAAe,mBAAmB,IAAI,kBAAkB;AACpF;AAGO,SAAS;IACd,uCAAmC;;IAEnC;AACF;AAGO,SAAS;IACd,wCAAmC,OAAO;;IAE1C,MAAM;IAGN,MAAM;AAER;AAGO,SAAS;IACd,wCAAmC;;IAEnC,MAAM;AASR;AAGO,SAAS;IACd,wCAAmC;;IAEnC,MAAM;IAEN,MAAM;AAcR;AAGO,SAAS;IACd,wCAAmC;;AAQrC","debugId":null}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/phuvm/source/repos/AnimeZ/src/lib/auth.ts"],"sourcesContent":["\"use client\";\r\n\r\nimport { createContext, useContext } from \"react\";\r\nimport { SessionData, AuthUser } from \"./types\";\r\n\r\n// Re-export AuthUser for convenience\r\nexport type { AuthUser };\r\nimport {\r\n  generateSessionToken,\r\n  generateFingerprint,\r\n  encryptSessionData,\r\n  decryptSessionData,\r\n  isSessionExpired,\r\n  isSessionNearExpiry,\r\n  isInactive,\r\n  updateLastActivity,\r\n  cleanupExpiredSessions,\r\n  setupActivityTracking,\r\n  setupVisibilityTracking,\r\n  STORAGE_KEYS,\r\n  SESSION_CONFIG,\r\n} from \"./session-security\";\r\n\r\nexport interface AuthContextType {\r\n  user: AuthUser | null;\r\n  isAuthenticated: boolean;\r\n  isLoading: boolean;\r\n  session: SessionData | null;\r\n  sessionTimeRemaining: number;\r\n  isSessionNearExpiry: boolean;\r\n  login: (email: string, password: string, rememberMe?: boolean) => Promise<boolean>;\r\n  logout: () => void;\r\n  signup: (userData: any) => Promise<boolean>;\r\n  refreshSession: () => void;\r\n  extendSession: () => void;\r\n}\r\n\r\nexport const AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\nexport function useAuth() {\r\n  console.log(AuthContext);\r\n  const context = useContext(AuthContext);\r\n  if (context === undefined) {\r\n    throw new Error(\"useAuth must be used within an AuthProvider\");\r\n  }\r\n  return context;\r\n}\r\n\r\n// Enhanced authentication service with session management\r\nexport const authService = {\r\n  // Save session to localStorage with encryption\r\n  saveSession: (user: AuthUser, rememberMe: boolean = false): SessionData => {\r\n    const now = Date.now();\r\n    const expirationTime = rememberMe \r\n      ? SESSION_CONFIG.rememberMeExpiration \r\n      : SESSION_CONFIG.defaultExpiration;\r\n    \r\n    const sessionData: SessionData = {\r\n      user,\r\n      token: generateSessionToken(),\r\n      expiresAt: now + expirationTime,\r\n      loginTime: now,\r\n      rememberMe,\r\n      fingerprint: generateFingerprint(),\r\n    };\r\n\r\n    const encryptedSession = encryptSessionData(sessionData);\r\n    localStorage.setItem(STORAGE_KEYS.SESSION, encryptedSession);\r\n    localStorage.setItem(STORAGE_KEYS.SESSION_FINGERPRINT, sessionData.fingerprint);\r\n    updateLastActivity();\r\n\r\n    return sessionData;\r\n  },\r\n\r\n  // Get current session from localStorage\r\n  getSession: (): SessionData | null => {\r\n    if (typeof window === \"undefined\") return null;\r\n\r\n    try {\r\n      const encryptedSession = localStorage.getItem(STORAGE_KEYS.SESSION);\r\n      if (!encryptedSession) return null;\r\n\r\n      const session = decryptSessionData(encryptedSession);\r\n      if (!session) return null;\r\n\r\n      // Validate session\r\n      if (isSessionExpired(session)) {\r\n        authService.clearSession();\r\n        return null;\r\n      }\r\n\r\n      // Check for inactivity\r\n      if (isInactive()) {\r\n        authService.clearSession();\r\n        return null;\r\n      }\r\n\r\n      // Validate fingerprint for security\r\n      const storedFingerprint = localStorage.getItem(STORAGE_KEYS.SESSION_FINGERPRINT);\r\n      if (storedFingerprint !== session.fingerprint) {\r\n        authService.clearSession();\r\n        return null;\r\n      }\r\n\r\n      return session;\r\n    } catch (error) {\r\n      console.error(\"Error retrieving session:\", error);\r\n      authService.clearSession();\r\n      return null;\r\n    }\r\n  },\r\n\r\n  // Clear session data\r\n  clearSession: (): void => {\r\n    localStorage.removeItem(STORAGE_KEYS.SESSION);\r\n    localStorage.removeItem(STORAGE_KEYS.LAST_ACTIVITY);\r\n    localStorage.removeItem(STORAGE_KEYS.SESSION_FINGERPRINT);\r\n    \r\n    // Also clear legacy auth data\r\n    localStorage.removeItem(\"isAuthenticated\");\r\n    localStorage.removeItem(\"user\");\r\n  },\r\n\r\n  // Check if session is valid\r\n  isSessionValid: (): boolean => {\r\n    const session = authService.getSession();\r\n    return session !== null;\r\n  },\r\n\r\n  // Refresh session (extend expiration)\r\n  refreshSession: (): SessionData | null => {\r\n    const currentSession = authService.getSession();\r\n    if (!currentSession) return null;\r\n\r\n    const now = Date.now();\r\n    const expirationTime = currentSession.rememberMe \r\n      ? SESSION_CONFIG.rememberMeExpiration \r\n      : SESSION_CONFIG.defaultExpiration;\r\n\r\n    const refreshedSession: SessionData = {\r\n      ...currentSession,\r\n      expiresAt: now + expirationTime,\r\n      token: generateSessionToken(), // Generate new token for security\r\n    };\r\n\r\n    const encryptedSession = encryptSessionData(refreshedSession);\r\n    localStorage.setItem(STORAGE_KEYS.SESSION, encryptedSession);\r\n    updateLastActivity();\r\n\r\n    return refreshedSession;\r\n  },\r\n\r\n  // Login with session management\r\n  login: async (email: string, password: string, rememberMe: boolean = false): Promise<{ success: boolean; user?: AuthUser; session?: SessionData }> => {\r\n    // Mock login - in real app, this would call your API\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n    \r\n    if (email && password) {\r\n      const user: AuthUser = {\r\n        id: \"1\",\r\n        email: email,\r\n        name: email === \"admin@tailadmin.com\" ? \"Musharof\" : \"User\",\r\n        avatar: \"/placeholder-avatar.jpg\"\r\n      };\r\n      \r\n      const session = authService.saveSession(user, rememberMe);\r\n      \r\n      return { success: true, user, session };\r\n    }\r\n    \r\n    return { success: false };\r\n  },\r\n\r\n  // Signup (unchanged but updated for consistency)\r\n  signup: async (userData: any): Promise<{ success: boolean; user?: AuthUser }> => {\r\n    // Mock signup - in real app, this would call your API\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n    \r\n    const user: AuthUser = {\r\n      id: Date.now().toString(),\r\n      email: userData.email,\r\n      name: userData.fullName,\r\n    };\r\n    \r\n    // In real app, you wouldn't store password in localStorage\r\n    localStorage.setItem(\"registeredUser\", JSON.stringify(user));\r\n    \r\n    return { success: true, user };\r\n  },\r\n\r\n  // Logout with proper session cleanup\r\n  logout: () => {\r\n    authService.clearSession();\r\n  },\r\n\r\n  // Get current user from session\r\n  getCurrentUser: (): AuthUser | null => {\r\n    const session = authService.getSession();\r\n    return session?.user || null;\r\n  },\r\n\r\n  // Check if user is authenticated\r\n  isAuthenticated: (): boolean => {\r\n    return authService.isSessionValid();\r\n  },\r\n\r\n  // Get session time remaining in milliseconds\r\n  getSessionTimeRemaining: (): number => {\r\n    const session = authService.getSession();\r\n    if (!session) return 0;\r\n    \r\n    const remaining = session.expiresAt - Date.now();\r\n    return Math.max(0, remaining);\r\n  },\r\n\r\n  // Check if session is near expiry\r\n  isSessionNearExpiry: (): boolean => {\r\n    const session = authService.getSession();\r\n    if (!session) return false;\r\n    \r\n    return isSessionNearExpiry(session);\r\n  },\r\n\r\n  // Initialize session management\r\n  initializeSessionManagement: (): (() => void) | void => {\r\n    if (typeof window === \"undefined\") return;\r\n\r\n    // Clean up any expired sessions on initialization\r\n    cleanupExpiredSessions();\r\n\r\n    // Set up activity tracking\r\n    const cleanupActivity = setupActivityTracking();\r\n    \r\n    // Set up visibility tracking\r\n    setupVisibilityTracking();\r\n\r\n    // Set up periodic session validation\r\n    const sessionCheckInterval = setInterval(() => {\r\n      const session = authService.getSession();\r\n      if (session && isSessionExpired(session)) {\r\n        authService.clearSession();\r\n        // Trigger a page reload or redirect to login\r\n        window.location.href = '/login';\r\n      }\r\n    }, 60000); // Check every minute\r\n\r\n    // Return cleanup function\r\n    return () => {\r\n      if (cleanupActivity) cleanupActivity();\r\n      clearInterval(sessionCheckInterval);\r\n    };\r\n  }\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/phuvm/source/repos/AnimeZ/src/components/auth-provider.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { ReactNode, useEffect, useState, useCallback } from \"react\";\r\nimport { AuthContext, AuthUser, authService } from \"@/lib/auth\";\r\nimport { SessionData } from \"@/lib/types\";\r\n\r\ninterface AuthProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\nexport function AuthProvider({ children }: AuthProviderProps) {\r\n  const [user, setUser] = useState<AuthUser | null>(null);\r\n  const [session, setSession] = useState<SessionData | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [sessionTimeRemaining, setSessionTimeRemaining] = useState(0);\r\n  const [isSessionNearExpiry, setIsSessionNearExpiry] = useState(false);\r\n\r\n  // Update session state\r\n  const updateSessionState = useCallback(() => {\r\n    const currentSession = authService.getSession();\r\n    const currentUser = authService.getCurrentUser();\r\n    const timeRemaining = authService.getSessionTimeRemaining();\r\n    const nearExpiry = authService.isSessionNearExpiry();\r\n\r\n    setSession(currentSession);\r\n    setUser(currentUser);\r\n    setSessionTimeRemaining(timeRemaining);\r\n    setIsSessionNearExpiry(nearExpiry);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // Initialize session management\r\n    const cleanup = authService.initializeSessionManagement();\r\n    \r\n    // Check if user is already authenticated on app load\r\n    updateSessionState();\r\n    setIsLoading(false);\r\n\r\n    // Set up periodic session state updates\r\n    const sessionUpdateInterval = setInterval(updateSessionState, 30000); // Update every 30 seconds\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      if (cleanup) cleanup();\r\n      clearInterval(sessionUpdateInterval);\r\n    };\r\n  }, [updateSessionState]);\r\n\r\n  const login = async (email: string, password: string, rememberMe?: boolean): Promise<boolean> => {\r\n    setIsLoading(true);\r\n    try {\r\n      const result = await authService.login(email, password, rememberMe);\r\n      if (result.success && result.user && result.session) {\r\n        setUser(result.user);\r\n        setSession(result.session);\r\n        updateSessionState();\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (error) {\r\n      console.error(\"Login error:\", error);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const signup = async (userData: any): Promise<boolean> => {\r\n    setIsLoading(true);\r\n    try {\r\n      const result = await authService.signup(userData);\r\n      if (result.success) {\r\n        // Don't auto-login after signup, redirect to login page\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (error) {\r\n      console.error(\"Signup error:\", error);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const logout = () => {\r\n    authService.logout();\r\n    setUser(null);\r\n    setSession(null);\r\n    setSessionTimeRemaining(0);\r\n    setIsSessionNearExpiry(false);\r\n  };\r\n\r\n  const refreshSession = () => {\r\n    const refreshedSession = authService.refreshSession();\r\n    if (refreshedSession) {\r\n      setSession(refreshedSession);\r\n      updateSessionState();\r\n    }\r\n  };\r\n\r\n  const extendSession = () => {\r\n    // Same as refresh for now, but could be different logic\r\n    refreshSession();\r\n  };\r\n\r\n  const value = {\r\n    user,\r\n    //isAuthenticated: !!user && !!session,\r\n    isAuthenticated: true,\r\n    isLoading,\r\n    session,\r\n    sessionTimeRemaining,\r\n    isSessionNearExpiry,\r\n    login,\r\n    logout,\r\n    signup,\r\n    refreshSession,\r\n    extendSession,\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={value}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;;AAUO,SAAS,aAAa,EAAE,QAAQ,EAAqB;IAC1D,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAmB;IAClD,MAAM,CAAC,SAAS,WAAW,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAsB;IAC3D,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAC3C,MAAM,CAAC,sBAAsB,wBAAwB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IACjE,MAAM,CAAC,qBAAqB,uBAAuB,GAAG,CAAA,GAAA,qMAAA,CAAA,WAAQ,AAAD,EAAE;IAE/D,uBAAuB;IACvB,MAAM,qBAAqB,CAAA,GAAA,qMAAA,CAAA,cAAW,AAAD,EAAE;QACrC,MAAM,iBAAiB,kHAAA,CAAA,cAAW,CAAC,UAAU;QAC7C,MAAM,cAAc,kHAAA,CAAA,cAAW,CAAC,cAAc;QAC9C,MAAM,gBAAgB,kHAAA,CAAA,cAAW,CAAC,uBAAuB;QACzD,MAAM,aAAa,kHAAA,CAAA,cAAW,CAAC,mBAAmB;QAElD,WAAW;QACX,QAAQ;QACR,wBAAwB;QACxB,uBAAuB;IACzB,GAAG,EAAE;IAEL,CAAA,GAAA,qMAAA,CAAA,YAAS,AAAD,EAAE;QACR,gCAAgC;QAChC,MAAM,UAAU,kHAAA,CAAA,cAAW,CAAC,2BAA2B;QAEvD,qDAAqD;QACrD;QACA,aAAa;QAEb,wCAAwC;QACxC,MAAM,wBAAwB,YAAY,oBAAoB,QAAQ,0BAA0B;QAEhG,mBAAmB;QACnB,OAAO;YACL,IAAI,SAAS;YACb,cAAc;QAChB;IACF,GAAG;QAAC;KAAmB;IAEvB,MAAM,QAAQ,OAAO,OAAe,UAAkB;QACpD,aAAa;QACb,IAAI;YACF,MAAM,SAAS,MAAM,kHAAA,CAAA,cAAW,CAAC,KAAK,CAAC,OAAO,UAAU;YACxD,IAAI,OAAO,OAAO,IAAI,OAAO,IAAI,IAAI,OAAO,OAAO,EAAE;gBACnD,QAAQ,OAAO,IAAI;gBACnB,WAAW,OAAO,OAAO;gBACzB;gBACA,OAAO;YACT;YACA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gBAAgB;YAC9B,OAAO;QACT,SAAU;YACR,aAAa;QACf;IACF;IAEA,MAAM,SAAS,OAAO;QACpB,aAAa;QACb,IAAI;YACF,MAAM,SAAS,MAAM,kHAAA,CAAA,cAAW,CAAC,MAAM,CAAC;YACxC,IAAI,OAAO,OAAO,EAAE;gBAClB,wDAAwD;gBACxD,OAAO;YACT;YACA,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iBAAiB;YAC/B,OAAO;QACT,SAAU;YACR,aAAa;QACf;IACF;IAEA,MAAM,SAAS;QACb,kHAAA,CAAA,cAAW,CAAC,MAAM;QAClB,QAAQ;QACR,WAAW;QACX,wBAAwB;QACxB,uBAAuB;IACzB;IAEA,MAAM,iBAAiB;QACrB,MAAM,mBAAmB,kHAAA,CAAA,cAAW,CAAC,cAAc;QACnD,IAAI,kBAAkB;YACpB,WAAW;YACX;QACF;IACF;IAEA,MAAM,gBAAgB;QACpB,wDAAwD;QACxD;IACF;IAEA,MAAM,QAAQ;QACZ;QACA,uCAAuC;QACvC,iBAAiB;QACjB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;IAEA,qBACE,8OAAC,kHAAA,CAAA,cAAW,CAAC,QAAQ;QAAC,OAAO;kBAC1B;;;;;;AAGP","debugId":null}}]
}